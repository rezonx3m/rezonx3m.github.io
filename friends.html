<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />
  <title>Друзья на карте</title>
  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>

  <style>
  html,
body,
#container {
  margin: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#main {
  padding: 0px;
  height: 100%;
}

#div-id {
  position: absolute;
  top: 30px;
  left: 30px;
}

.ava {
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  border-radius: 0px;
  background-size: cover;
  background-color: gray;
  color: white;
  font-weight: bold;
  text-align: center;
  transition-duration: 0.2s;
  transition-property: transform;
}

.ava-only-text {
  display: flex;
  align-items: center;
  justify-content: center;
}

.fired-ava-container {
  height: 31px;
  width: 31px;
  border-radius: 100px;
  color: #262626;
  background: #ffffff;
  box-shadow: 0px 0px 5px white;
  overflow: hidden;
  position: absolute;
  top: 24px;
  left: 42px;
  box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
  overflow: hidden;
  border: 3px solid white;
  animation: scale 2s ease-in-out infinite;
}

.ava-container {
  height: 31px;
  width: 31px;
  border-radius: 100px;
  color: #262626;
  background: #ffffff;
  box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
  overflow: hidden;
  border: 3px solid white;
  animation: scale 2s ease-in-out infinite;
}

.fire-marker-container {
  transform-origin: 70% 50%;
  transition-duration: 0.2s;
  transition-property: transform;
}

@keyframes scale {
  0% {
    transform: scale(1);
  }
  5% {
    transform: scale(1);
  }
  45% {
    transform: scale(1.05);
  }
  55% {
    transform: scale(1.05);
  }
  95% {
    transform: scale(1);
  }
  100% {
    transform: scale(1);
  }
}

.emoji-marker {
  font-size: 20px;
  animation: emoji-scale 0.5s ease-in-out;
  -webkit-animation: emoji-scale 0.5s ease-in-out;
}

@keyframes emoji-scale {
  0% {
    transform: scale(1);
    -webkit-transform: scale(1);
  }
  75% {
    transform: scale(5);
    -webkit-transform: scale(5);
  }
  100% {
    transform: scale(0);
    -webkit-transform: scale(0);
  }
}

.hidden-test-button {
  display: none;
}

  </style>
</head>

<body>
  <div id="main">
    <div id="container"></div>
  </div>
  
  <div id="controls">
    <div id="div-id">
      <input id="input-id" size="10" placeholder="userid" />
      <button onClick="changeId();">connect</button>
  
      <button class="hidden-test-button" onClick="test1();">random move</button>
      <button class="hidden-test-button" onClick="test2();">move to rechnik</button>
      <button class="hidden-test-button" onClick="test3();">random rotate</button>
  
    </div>
  </div>

  <script type="text/javascript">
 const DEBUG = false;

if (DEBUG) {
  const buttons = document.getElementsByClassName("hidden-test-button");
  for (let i = buttons.length - 1; i >= 0; i--) {
    buttons[i].classList.remove("hidden-test-button");
  }
}

const map = new mapgl.Map("container", {
  center: [82.963483, 55.009882],
  zoom: 13,
  key: "042b5b75-f847-4f2a-b695-b5f58adc9dfd"
});

// 21642
const myId = "cd3f16bcdd5b4fc7a9bb02ba68e75536";

// 45755262
const testId = "d33df51bd4ce41e7a5bbbe28bc4cfc35";

var testMessage = {
  type: "friendState",
  payload: {
    id: myId,
    lastSeen: 1698736151973,
    location: {
      lat: 55.01,
      lon: 82.95,
      azimuth: 206.91267,
      speed: 160,
      accuracy: 17.823999404907227
    },
    battery: {
      level: 0.81
    },
    movement: {
      status: "moving",
      stoppedAt: 1698728448409
    }
  }
};

function test1() {
  processMessage(testMessage);
  const multiplier1 = Math.random() > 0.5 ? 1 : -1;
  const multiplier2 = Math.random() > 0.5 ? 1 : -1;
  testMessage.payload.location.lon += 0.01 * multiplier1;
  testMessage.payload.location.lat += 0.01 * multiplier2;
}

function test2() {
  testMessage.payload.location.lon = 82.936536;
  testMessage.payload.location.lat = 55.007961;
  processMessage(testMessage);
}

function test3() {
  rotateMarker(myId, Math.random() * 360);
}

var globalProfiles = {};
var globalMarkers = {};
var globalStates = {};
var globalWS = null;
var globalMapRotation = 0;

const SOCKET_PATH = "wss://zond.api.2gis.ru/api/1.1/user/:id/ws";

const FIRE_MARKER_CONTAINER = "fire-marker-container";
const BASIC_MARKER_CONTAINER = "basic-marker-container";
const STATE_MOVING = "moving";
const STATE_STOPPED = "stopped";

const BASE_ANIMATION_TIME = 0.2;
const BASE_SPEED = 1;

function changeId() {
  clearAll();
  globalWS = initSocket(document.getElementById("input-id").value);
}

function clearAll() {
  globalProfiles = {};
  for (const id in globalMarkers) {
    removeMarker(id);
  }
  globalMarkers = {};
  globalStates = {};

  if (globalWS !== null) {
    globalWS.close();
  }
}

function setStateConnected() {}

function initSocket(id) {
  const wssUrlPattern = SOCKET_PATH;
  const wssUrl = wssUrlPattern.replace(":id", id);
  const ws = new WebSocket(wssUrl);

  ws.onopen = function () {
    sendBounds(ws);
  };

  ws.onerror = function (e) {
    console.log("ws error");
    console.log(e);
  };
  ws.onclose = function () {
    console.log("ws closed");
  };

  ws.onmessage = function (msgevent) {
    const msg = JSON.parse(msgevent.data);
    processMessage(msg);
  };

  return ws;
}

function processMessage(msg) {
  switch (msg.type) {
    case "initialState":
      processInitState(msg.payload);
      break;

    case "friendState":
      processState(msg.payload);
      break;

    case "friendRemoved":
      removeProfile(msg.payload);
      break;

    case "profile":
      addProfile(msg.payload);
      break;

    case "stickersInitialState":
      break;

    case "stickerReceived":
      processStickerToMe(msg.payload);
      break;

    default:
      console.log("unsupported type", msg.type, msg.payload);
      break;
  }
}

function processInitState(payload) {
  payload.profiles.forEach((profile) => {
    addProfile(profile);
  });
  payload.states.forEach((state) => {
    processState(state);
  });
}

function addProfile(profile) {
  const key = profile.id;
  globalProfiles[key] = profile;
}

function removeProfile(id) {
  delete globalProfiles[id];
  removeMarker(id);
  delete globalStates[id];
}

function removeMarker(id) {
  if (globalMarkers.hasOwnProperty(id)) {
    globalMarkers[id].destroy();
    delete globalMarkers[id];
  }
}

function processState(state) {
  const id = state.id;
  const lon = state.location.lon;
  const lat = state.location.lat;
  const isInit = !globalStates.hasOwnProperty(id);

  const marker = isInit ? null : globalMarkers[id];
  const lastLon = isInit ? null : globalStates[id]["lon"];
  const lastLat = isInit ? null : globalStates[id]["lat"];

  const locationSpeed = state.location.hasOwnProperty("speed")
    ? state.location.speed
    : BASE_SPEED;
  const animationTime = isInit
    ? BASE_ANIMATION_TIME
    : calculateAnimationTime(lastLat, lastLon, lat, lon, state.location.speed);
  const azimuth = isInit ? null : bearing(lastLat, lastLon, lat, lon);

  if (isInit) {
    globalStates[id] = {};
  }

  const isMoving = state.movement.status == STATE_MOVING ? true : false;
  const avaUrl = globalProfiles[id].logo;
  const name = globalProfiles[id].name;

  // для дебага, чтобы проверить соответствуют ли маркера реальным позициям
  if (DEBUG) {
    const debugMarker = new mapgl.Marker(map, {
      coordinates: [lon, lat]
    });
  }

  switch (true) {
    case !isInit && !isMoving: // кейсы, когда маркер останавливается
      if (globalStates[id]["state"] == STATE_STOPPED) {
        // маркер остался стоять, но теоретически могла прилететь новая позиция
        moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
      } else {
        // маркер был движущимся, а стал cтоящим, поэтому заменяем
        // @todo рассчитать скорость
        moveMarker(id, marker, lastLon, lastLat, lon, lat, animationTime);
        globalMarkers[id] = addOrReplaceMarker(
          id,
          lon,
          lat,
          isInit,
          isMoving,
          null,
          avaUrl,
          name
        );
        globalStates[id]["state"] = STATE_STOPPED;
      }
      break;
    case !isInit && isMoving: // кейсы, когда маркер движется
      if (globalStates[id]["state"] == STATE_STOPPED) {
        // раньше стоял, начал двигаться, меняем маркер и стейт
        // рисуем маркер сперва в предыдущей точке
        globalMarkers[id] = addOrReplaceMarker(
          id,
          lastLon,
          lastLat,
          isInit,
          isMoving,
          azimuth,
          avaUrl,
          name
        );

        moveMarker(
          id,
          globalMarkers[id],
          lastLon,
          lastLat,
          lon,
          lat,
          animationTime
        );
        globalStates[id]["state"] = STATE_MOVING;
      } else {
        rotateMarker(id, azimuth);
        moveMarker(id, marker, lastLon, lastLat, lon, lat, animationTime);
      }
      break;
    case isInit:
      globalMarkers[id] = addOrReplaceMarker(
        id,
        lon,
        lat,
        isInit,
        false,
        null,
        avaUrl,
        name
      );
      globalStates[id]["state"] = STATE_STOPPED;
      break;
    default:
      console("hbz case");
  }

  globalStates[id]["lon"] = lon;
  globalStates[id]["lat"] = lat;
  globalStates[id]["azimuth"] = azimuth;
}

function addOrReplaceMarker(
  id,
  lon,
  lat,
  isInit,
  isMoving,
  azimuth,
  avaUrl,
  name
) {
  removeMarker(id);

  const markerClass =
    isMoving && !isInit // маркер из инита всегда рисуем стоячим
      ? // Math.random() < 0.5 ?
        FIRE_MARKER_CONTAINER
      : BASIC_MARKER_CONTAINER;

  const acronym = name
    .split(/\s/)
    .reduce((response, word) => (response += word.slice(0, 1)), "");

  const htmlMarker = new mapgl.HtmlMarker(map, {
    coordinates: [lon, lat],
    interactive: false,
    html: getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth)
  });

  if (markerClass === FIRE_MARKER_CONTAINER) {
    htmlMarker.setAnchor([58, 50]);
  } else {
    htmlMarker.setAnchor([18, 25]);
  }

  return htmlMarker;
}

function getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth) {
  var html = "";

  const backgroundImage =
    avaUrl !== null ? "background-image: url(" + avaUrl + ");" : null;

  if (backgroundImage !== null) {
    acronym = "";
  }

  const rotateText = azimuth !== null ? azimuth + "deg" : "0deg";
  const invertRotateText = azimuth !== null ? azimuth * -1 + "deg" : "0deg";

  const textClass = acronym != "" ? "ava-only-text" : "";

  if (markerClass === FIRE_MARKER_CONTAINER) {
    html = `
      <div id="marker-${id}" class="${markerClass}" style="transform: rotate(${rotateText});">
        <dotlottie-player src="https://lottie.host/8dd41a0e-5c47-4646-a8f7-0adb8d4a7f88/HxGxgGoHVp.json" background="transparent" speed="1" style="width: 84px; height: 84px;" loop autoplay>
        </dotlottie-player>
        <div class="fired-ava-container">
          <div id="ava-${id}" style="${backgroundImage}; transform: rotate(${invertRotateText});" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
  } else {
    html = `<div id="marker-${id}" class="${markerClass}">
        <div class="ava-container">
          <div id="ava-${id}" style="${backgroundImage};" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
  }
  return html;
}

function toRadians(degrees) {
  return (degrees * Math.PI) / 180;
}

// Converts from radians to degrees.
function toDegrees(radians) {
  return (radians * 180) / Math.PI;
}

function bearing(startLat, startLon, destLat, destLon) {
  startLat = toRadians(startLat);
  startLon = toRadians(startLon);
  destLat = toRadians(destLat);
  destLon = toRadians(destLon);

  y = Math.sin(destLon - startLon) * Math.cos(destLat);
  x =
    Math.cos(startLat) * Math.sin(destLat) -
    Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLon - startLon);
  brng = Math.atan2(y, x);
  brng = toDegrees(brng);
  return ((brng + 360) % 360) - 90;
}

function moveMarker(
  id,
  marker,
  prevLon,
  prevLat,
  currentLon,
  currentLat,
  time
) {
  const mapLon = marker.getCoordinates()[0];
  const mapLat = marker.getCoordinates()[1];

  const track = [
    { coordinates: [mapLon, mapLat], t: 0 },
    { coordinates: [prevLon, prevLat], t: 0.2 },
    { coordinates: [currentLon, currentLat], t: time }
  ];

  // делаем анимацию для значимых движений
  if (
    Math.abs(prevLon - currentLon) > 0.0001 ||
    Math.abs(prevLat - currentLat) > 0.0001
  ) {
    moveOn(id, track, marker);
  }
}

function rotateMarker(id, azimuth) {
  const fixedAzimuth = azimuth + globalMapRotation;
  const avaElement = document.getElementById(`ava-${id}`);
  const markerElement = document.getElementById(`marker-${id}`);
  const invertAzimut = fixedAzimuth * -1;
  markerElement.style.transform = `rotate(${fixedAzimuth}deg)`;
  avaElement.style.transform = `rotate(${invertAzimut}deg)`;
}

async function moveOn(userId, track, marker) {
  // current segment index
  let i = 0;

  // startup absolute time
  const start = performance.now();

  // segment points
  let curr = track[i],
    next = track[i + 1];

  // сохраняем рандомный номер созданной анимации, чтобы не играть те, что не актуальны
  const animationRandomNumber = Math.random();
  globalStates[userId]["animationRandomNumber"] = animationRandomNumber;

  while (
    next &&
    globalStates[userId]["animationRandomNumber"] == animationRandomNumber
  ) {
    if (DEBUG) {
      console.log(animationRandomNumber);
    }
    // time from start, ms
    const dt = (performance.now() - start) / 1000;

    // position in segment
    const ratio = (dt - curr.t) / (next.t - curr.t);

    // get current pos via lienar interpolation
    const pos = lerp(curr.coordinates, next.coordinates, ratio);
    marker.setCoordinates(pos);

    // wait next animation frame
    await new Promise((resolve) => requestAnimationFrame(resolve));

    // iterate segments if needed
    if (dt > next.t) {
      i += 1;
      curr = next;
      next = track[i + 1];
    }
  }
}

function lerp(x, y, ratio) {
  return [x[0] + (y[0] - x[0]) * ratio, x[1] + (y[1] - x[1]) * ratio];
}

function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
  const R = 6371; // Radius of the earth in km
  const dLat = toRadians(lat2 - lat1); // deg2rad below
  const dLon = toRadians(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(lat1)) *
      Math.cos(toRadians(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const d = R * c; // Distance in km
  return d;
}

function calculateAnimationTime(lastLat, lastLon, lat, lon, speed) {
  const distInMeters =
    getDistanceFromLatLonInKm(lastLat, lastLon, lat, lon) * 1000;
  const time = distInMeters / speed;
  return time;
}

// фиксим рамер карты при ресайзе
window.addEventListener("resize", () => map.invalidateSize());

function reRotateMarkers() {
  for (const id in globalStates) {
    if (globalStates[id]["state"] == STATE_MOVING) {
      rotateMarker(id, globalStates[id]["azimuth"]);
    }
  }
}

// при окончании вращения карты сохраняем поправочный коэффициент
// шлем вьюпорт
map.on("rotationend", () => {
  globalMapRotation = map.getRotation();
  reRotateMarkers();
});

map.on("moveend", () => {
  sendBounds(globalWS);
});

map.on("zoomend", () => {
  //sendBounds(globalWS);
});

function sendBounds(ws) {
  if (ws) {
    const bounds = map.getBounds();
    const message = {
      type: "viewportChanged",
      payload: {
        zoom: Math.floor(map.getZoom()),
        viewport: {
          topLeft: {
            lon: bounds.northEast[0],
            lat: bounds.northEast[1]
          },
          bottomRight: {
            lon: bounds.southWest[0],
            lat: bounds.southWest[1]
          }
        }
      }
    };

    const jsonMessage = JSON.stringify(message);
    ws.send(jsonMessage);
    if (DEBUG) {
      console.log(jsonMessage);
    }
  }
}

function processStickerToMe(payload) {
  const senderId = payload.senderId;
  const stickerId = payload.stickerRecord.sticker.stickerId;
  const stickersCount = payload.stickerRecord.sticker.count;
  spawnEmoji(senderId, stickerId, stickersCount);
}

function spawnEmoji(senderId, stickerId, stickersCount) {
  //  startCoordinates = globalStates
  //const senderLon = globalStates[senderId]["lon"];
  //const senderLat = globalStates[senderId]["lat"];
  const senderMarker = globalMarkers[senderId];
  const senderLon = senderMarker.getCoordinates()[0];
  const senderLat = senderMarker.getCoordinates()[1];

  const mapCenter = map.getCenter();

  var markerText = "";

  switch (stickerId) {
    case "fire": // fire
      markerText = "🔥";
      break;
    case "greenheart": // greenheart
      markerText = "💚";
      break;
    case "snowball": // snowball
      markerText = "❄️";
      break;
    case "poop": // poop
      markerText = "💩";
      break;
    case "wavinghand": // wavinghand
      markerText = "👋";
      break;
    case "angry": // angry
      markerText = "😡";
      break;
    case "eyes": // eyes
      markerText = "👀";
      break;
    case "party": // party
      markerText = "🎉";
      break;

    default:
      // go
      console.log("unsupported emoji", stickerId);
  }
  const htmlMarker = new mapgl.HtmlMarker(map, {
    coordinates: [senderLon, senderLat],
    interactive: true, // @todo false
    html: "<div class='emoji-marker'>" + markerText + "</div>"
  });
  htmlMarker.setAnchor([10, 16]);
  setTimeout(function () {
    htmlMarker.destroy();
  }, 500); // change time if changed animation css time
}

  </script>
</body>

</html>