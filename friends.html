<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />
  <title>Друзья на карте</title>
  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>

  <style>
    html,
    body,
    #container {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #main {
      padding: 0px;
      height: 100%;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
    }

    #connect-button {
      width: 100px;
    }

    #connect-status {
      background-color: #ff8f8f;
      width: 100px;
    }

    #test-buttons {
      display: none;
    }

    .test-buttons-line {
      padding-top: 3px;
    }

    .ava {
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      /* border-radius: 0px; */
      background-size: cover;
      background-color: gray;
      color: white;
      font-weight: bold;
      text-align: center;
    }

    .ava-only-text {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fired-ava-container {
      height: 32px;
      width: 32px;
      border-radius: 100px;
      color: #262626;
      background: #ffffff;
      box-shadow: 0px 0px 5px white;
      overflow: hidden;
      position: absolute;
      top: 24px;
      left: 42px;
      box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
      overflow: hidden;
      border: 3px solid white;
      animation: scale 2s ease-in-out infinite;
    }

    .ava-container {
      height: 32px;
      width: 32px;
      border-radius: 100px;
      color: #262626;
      background: #ffffff;
      box-shadow: 0px 0px 2px 2px rgba(38, 38, 38, 0.5);
      overflow: hidden;
      border: 3px solid white;
      animation: scale 2s ease-in-out infinite;
    }

    .cluster-ava-container {
      height: 32px;
      width: 32px;
      border-radius: 100px;
      color: #262626;
      background: #ffffff;
      box-shadow: 0px 0px 4px 4px rgba(235, 87, 22, 0.8);
      overflow: hidden;
      border: 3px solid white;
      animation: scale 2s ease-in-out infinite;
    }

    .fire-marker-container {
      transform-origin: 70% 50%;
      transition-duration: 0.2s;
      transition-property: transform;
    }

    @keyframes scale {
      0% {
        transform: scale(1);
      }

      5% {
        transform: scale(1);
      }

      45% {
        transform: scale(1.05);
      }

      55% {
        transform: scale(1.05);
      }

      95% {
        transform: scale(1);
      }

      100% {
        transform: scale(1);
      }
    }

    .emoji-marker {
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center center;
      width: 20px;
      height: 20px;
      min-width: 20px;
      min-height: 20px;
      animation: emoji-scale 1s ease-in-out;
      -webkit-animation: emoji-scale 1s ease-in-out;
    }

    @keyframes emoji-scale {
      0% {
        transform: scale(1);
        -webkit-transform: scale(1);
      }

      70% {
        transform: scale(5);
        -webkit-transform: scale(5);
      }

      100% {
        transform: scale(1);
        -webkit-transform: scale(1);
      }
    }

    .hidden-test-button {
      display: none;
    }

    .emogi-fire {
      background-image: url("https://cachizer1.2gis.com/common/8f10cf05-f9fd-467b-888b-ea9c38d48171.png?w=200&h=200");
    }

    .emogi-greenheart {
      background-image: url("https://cachizer2.2gis.com/common/6085e54d-15f0-41c8-90c8-3257b2c1c03a.png?w=200&h=200");
    }

    .emogi-snowball {
      background-image: url("https://cachizer1.2gis.com/common/07336686-7ecd-4f3d-afa8-925de33b6c62.png?w=200&h=200");
    }

    .emogi-poop {
      background-image: url("https://cachizer2.2gis.com/common/ab98af20-0d27-4e4d-8555-82c0fa0fe8b8.png?w=200&h=200");
    }

    .emogi-wavinghand {
      background-image: url("https://cachizer1.2gis.com/common/f3b8ac5d-1f67-44ff-b8c3-f6aceec3beb9.png?w=200&h=200");
    }

    .emogi-angry {
      background-image: url("https://cachizer2.2gis.com/common/339d8ffa-735f-47c9-b557-5cf3a4f6abb1.png?w=200&h=200");
    }

    .emogi-eyes {
      background-image: url("https://cachizer1.2gis.com/common/905959df-f128-4691-8686-dd9b11b9ce63.png?w=200&h=200");
    }

    .emogi-party {
      background-image: url("https://cachizer3.2gis.com/common/7e392598-710c-4340-80cb-c0b3b47b6741.png?w=200&h=200");
    }

    .emogi-go {
      background-image: url("https://cachizer3.2gis.com/common/466a8841-50d8-4b92-bea7-c280a693a25c.png?w=200&h=200");
    }

    .emogi-nav {
      background-image: url("https://cachizer2.2gis.com/common/e213fd69-105d-441c-8fe9-426c42b39d7c.png?w=200&h=200");
    }

    /* fade in out */

    #popup {
      position: absolute;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
      background-image: url("https://rezonx3m.github.io/friends/static/port-qr-code.png");
      background-repeat: no-repeat;
      background-position: center center;
      -webkit-animation: fadeinout 10s linear infinite;
      animation: fadeinout 10s linear infinite;
      opacity: 0;
      display: none;
    }

    @-webkit-keyframes fadeinout {
      10% {
        opacity: 1;
      }

      90% {
        opacity: 1;
      }
    }

    @keyframes fadeinout {
      10% {
        opacity: 1;
      }

      90% {
        opacity: 1;
      }
    }

    /* sliders */

    .itcss_item_text {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 32px;
      width: 32px;
      background-color: gray;
    }

    .itcss_item_ava {
      height: 32px;
      width: 32px;
      background-size: cover;
      background-color: gray;
    }
  </style>
</head>

<body>
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />
  <link rel="stylesheet" href="https://rezonx3m.github.io/friends/static/simple-adaptive-slider.css">
  <script defer src="https://rezonx3m.github.io/friends/static/simple-adaptive-slider.js"></script>

  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/mapgl-snow"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>


  <div id="main">
    <div id="container"></div>
  </div>

  <div id="popup" class="elementToFadeInAndOut">
  </div>

  <div id="controls">
    <div id="div-id">
      <input id="input-id" size="10" placeholder="userid" />
      <button id="connect-button" onClick="connectButtonClick();">connect</button>
      <button disabled id="connect-status">disconnected</button>
    </div>
    <div id="test-buttons">
      <div class="test-buttons-line">
        <button onClick="testMove();">random move</button>
        <button onClick="testRotate();">random rotate</button>
        <button onClick="testRandomSticker();">send random sticker</button>
        <div class="test-buttons-line">
          <button onClick="perfTest();">perf tests</button>
        </div>
        <div class="test-buttons-line">
          <button onClick="startScene2fest();">2fest scene</button>
          <button onClick="startScenePort();">port</button>
        </div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    const urlParams = new URLSearchParams(window.location.search);
    const getParamDebugMarkers = urlParams.get("debug_markers");
    const getParamDebug = urlParams.get("debug");
    const getParamUserId = urlParams.get("user_id");
    const getParamScene = urlParams.get("scene");
    // включаем дебак для кодпена или по параметру
    const DEBUG = window.location.host == "cdpn.io" || getParamDebug === "true";
    const ENABLE_DEBUG_MARKERS =
      window.location.host == "cdpn.io" || getParamDebugMarkers === "true";
    var debugMarkers = [];

    const ENABLE_AUTO_RECONNECT = true;
    const ENABLE_CLUSTERS = true;

    // маркера в кластерах (для быстрой чистки)
    var clusterMarkers = {};
    // идентификаторы юрезов в кластерах, для скрытия и восстановления основных маркеров @todo обощить с маркерами
    var idsUsersInClusters = {};

    var currentScene = null;

    var needReconnect = false;
    var reconnectTimerId = null;
    // таймер для пинг мессажа
    var connectTimerId = null;

    var isConnected = false;

    // используем таймауты с бека или же свои
    // @todo сделать таймер по обновлению маркеров раз в минуту
    const ENABLE_TIMEOUTS_FROM_BACKEND = false;
    var movingLivenessTimeout = 120000;
    var stoppedLivenessTimeout = 1000 * 60 * 60 * 24;
    // поправка на серверное вренмя
    var serverTimestampShift = 0;

    // список поддерживаемых эмодзи, при расширенни добавить css
    const SUPPORTED_EMOJI = [
      "fire",
      "greenheart",
      "snowball",
      "poop",
      "wavinghand",
      "angry",
      "eyes",
      "party",
      "go",
      "nav"
    ];

    const map = new mapgl.Map("container", {
      center: [82.963483, 55.039882],
      zoom: 12,
      key: "2a5f353b-5172-411f-b1a2-8ea58b3f290c",
      floorsEnabled: false,
      minZoom: 2,
      maxZoom: 20,
      minPitch: 0,
      maxPitch: 70,
      lowZoomMaxPitch: 45,
      zoomControl: false
    });

    // фиксим рамер карты при ресайзе
    window.addEventListener("resize", () => map.invalidateSize());

    // глобальный стейт @todo обобщить
    var globalProfiles = {};
    var globalMarkers = {};
    var globalStates = {};

    var globalWS = null;
    // поправочный коэффциент на вращение карты, чтобы огонь и аватарки были правильно повернуты
    var globalMapRotation = 0;
    const maxDebugMarkersLenght = 1000;

    const SOCKET_PATH =
      "wss://casino-zond-debug-api-production.k8s.n3.2gis.io/api/1.1/user/:id/ws";

    const FIRE_MARKER_CONTAINER = "fire-marker-container";
    const BASIC_MARKER_CONTAINER = "basic-marker-container";
    const STATE_MOVING = "moving";
    const STATE_STOPPED = "stopped";

    const BASE_ANIMATION_TIME = 0.2;
    const BASE_SPEED = 1;

    if (DEBUG) {
      hideVisibilityTestButtons(false);
    }

    if (getParamUserId !== null) {
      document.getElementById("input-id").value = getParamUserId;
      connectButtonClick();
    }

    // скрытие кнопок дле тестов
    function hideVisibilityTestButtons(hide) {
      const button = document.getElementById("test-buttons");
      if (hide) {
        button.style.display = "none";
      } else {
        button.style.display = "block";
      }
    }

    // управления контролами и статусом коннекта
    function setConnectionState(state) {
      const button = document.getElementById("connect-button");
      const status = document.getElementById("connect-status");
      const input = document.getElementById("input-id");
      status.innerText = state;
      switch (state) {
        case "connected":
          status.style.backgroundColor = "#9cf19c";
          input.disabled = true;
          button.innerText = "disconnect";
          isConnected = true;
          break;
        case "reconnecting":
          status.style.backgroundColor = "#fc8016";
          break;
        case "connecting":
          status.style.backgroundColor = "#839bff";
          break;
        case "disconnected":
          status.style.backgroundColor = "#ff8f8f";
          button.innerText = "connect";
          input.disabled = false;
          isConnected = false;
          break;
      }
    }

    // нажатие в кнопку коннекта
    function connectButtonClick() {
      const userId = document.getElementById("input-id").value;
      if (userId.length > 0) {
        if (!isConnected) {
          hideVisibilityTestButtons(true);
          setConnectionState("connecting");
          globalWS = initSocket(document.getElementById("input-id").value);
        } else {
          if (globalWS) {
            needReconnect = false;
            globalWS.close();
          }
          setConnectionState("disconnected");
        }
      }
    }

    // уничтожение всех данных
    function clearAll() {
      globalProfiles = {};
      for (const id in globalMarkers) {
        removeMarker(id);
      }

      debugMarkers.forEach((element) => element.destroy());

      globalMarkers = {};
      globalStates = {};
    }

    // инициализация соккета
    function initSocket(id) {
      const wssUrlPattern = SOCKET_PATH;
      const wssUrl = wssUrlPattern.replace(":id", id);
      const ws = new WebSocket(wssUrl);

      clearInterval(reconnectTimerId);

      ws.onopen = function () {
        // чистимся от греха подальше, так как в коннекте прилетит инит
        clearAll();
        // отправка баундов, чтобы слежение было во вьюпорте
        sendBounds(ws);
        // при открытие соккета сообщаем, что его нужно реконнектить
        needReconnect = true;
        // циклически отправляем пинг, чтобы брайзер понял, что коннект сдох на случай проблем
        connectTimerId = setInterval(() => {
          ws.send('{"type":"ping-from-web-ui","payload":{}}');
        }, 1000);
        setConnectionState("connected");
      };

      ws.onclose = function () {
        console.log("ws closed");
        // стираем старый интервал
        clearInterval(connectTimerId);
        // шедулим новый интервал для реконнекта
        reconnectTimerId = setInterval(() => {
          if (needReconnect && ENABLE_AUTO_RECONNECT) {
            setConnectionState("reconnecting");
            globalWS = initSocket(id);
          }
        }, 5000);
      };

      ws.onerror = function (e) {
        console.log("ws error");
        console.log(e);
        ws.close();
      };

      ws.onmessage = function (msgevent) {
        const msg = JSON.parse(msgevent.data);
        processMessage(msg);
      };

      return ws;
    }

    // обработка входящих
    function processMessage(msg) {
      switch (msg.type) {
        case "initialState":
          processInitState(msg.payload);
          break;

        case "friendState":
          processState(msg.payload);
          break;

        case "friendRemoved":
          removeProfile(msg.payload);
          break;

        case "profile":
          addProfile(msg.payload);
          break;

        case "stickersInitialState":
          break;

        case "stickerReceived":
          processStickerToMe(msg.payload);
          break;

        default:
          console.log("unsupported type", msg.type, msg.payload);
          break;
      }
    }

    function processInitState(payload) {
      if (DEBUG) {
        console.log("markerSettings", payload.markerSettings);
      }
      if (ENABLE_TIMEOUTS_FROM_BACKEND) {
        movingLivenessTimeout = payload.markerSettings.movingLivenessTimeout;
        stoppedLivenessTimeout = payload.markerSettings.stoppedLivenessTimeout;
      }
      // поправка на серверное время
      serverTimestampShift = Date.now() - payload.serverTime;

      payload.profiles.forEach((profile) => {
        addProfile(profile);
      });
      payload.states.forEach((state) => {
        processState(state);
      });
    }

    function addProfile(profile) {
      const key = profile.id;
      globalProfiles[key] = profile;
      // @todo менять маркер, если поменялась аватарка
    }

    function removeProfile(id) {
      delete globalProfiles[id];
      removeMarker(id);
      delete globalStates[id];
    }

    function removeMarker(id) {
      if (globalMarkers.hasOwnProperty(id)) {
        globalMarkers[id].destroy();
        delete globalMarkers[id];
      }
    }

    function processState(state) {
      const id = state.id;
      const lastSeen = state.lastSeen;
      const lon = state.location.lon;
      const lat = state.location.lat;
      // первое вхождение на карту
      const isInit = !globalStates.hasOwnProperty(id);

      // дропаем "серые" (давно стоящие) маркера
      if (Date.now() + serverTimestampShift - lastSeen > stoppedLivenessTimeout) {
        removeMarker(id);
        return;
      }

      const marker = isInit ? null : globalMarkers[id];
      const lastLon = isInit ? null : globalStates[id]["lon"];
      const lastLat = isInit ? null : globalStates[id]["lat"];

      const locationSpeed = state.location.hasOwnProperty("speed")
        ? state.location.speed
        : BASE_SPEED;
      const animationTime = isInit
        ? BASE_ANIMATION_TIME
        : calculateAnimationTime(lastLat, lastLon, lat, lon, state.location.speed);
      const azimuth = isInit
        ? null
        : bearing(marker.getCoordinates()[1], marker.getCoordinates()[0], lat, lon);

      if (isInit) {
        globalStates[id] = {};
      }

      // если маркер двигался давно, делаем его стоящим
      const isOldMovingData =
        Date.now() + serverTimestampShift - lastSeen > movingLivenessTimeout
          ? true
          : false;
      const isMoving =
        state.movement.status == STATE_MOVING && !isOldMovingData ? true : false;

      const avaUrl = globalProfiles[id].logo;
      const name = globalProfiles[id].name;

      // для дебага, чтобы проверить соответствуют ли маркера реальным позициям
      addDebugMarker(lon, lat);

      switch (true) {
        case !isInit && !isMoving: // кейсы, когда маркер останавливается
          if (globalStates[id]["state"] == STATE_STOPPED) {
            // маркер остался стоять, но теоретически могла прилететь новая позиция
            moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
          } else {
            // маркер был движущимся, а стал cтоящим, поэтому заменяем
            moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
            globalMarkers[id] = addOrReplaceMarker(
              id,
              lon,
              lat,
              isInit,
              isMoving,
              null,
              avaUrl,
              name
            );
            globalStates[id]["state"] = STATE_STOPPED;
          }
          break;
        case !isInit && isMoving: // кейсы, когда маркер движется
          if (globalStates[id]["state"] == STATE_STOPPED) {
            // раньше стоял, начал двигаться, меняем маркер и стейт
            // рисуем маркер сперва в предыдущей точке
            globalMarkers[id] = addOrReplaceMarker(
              id,
              lastLon,
              lastLat,
              isInit,
              isMoving,
              azimuth,
              avaUrl,
              name
            );

            moveMarker(
              id,
              globalMarkers[id],
              lastLon,
              lastLat,
              lon,
              lat,
              animationTime
            );
            globalStates[id]["state"] = STATE_MOVING;
          } else {
            rotateMarker(id, azimuth);
            moveMarker(id, marker, lastLon, lastLat, lon, lat, animationTime);
          }
          break;
        case isInit:
          globalMarkers[id] = addOrReplaceMarker(
            id,
            lon,
            lat,
            isInit,
            false,
            null,
            avaUrl,
            name
          );
          globalStates[id]["state"] = STATE_STOPPED;
          break;
        default:
          console("hbz case");
      }

      globalStates[id]["lon"] = lon;
      globalStates[id]["lat"] = lat;
      globalStates[id]["azimuth"] = azimuth;

      clusteriseMarkers();
    }

    function addOrReplaceMarker(
      id,
      lon,
      lat,
      isInit,
      isMoving,
      azimuth,
      avaUrl,
      name
    ) {
      removeMarker(id);

      const markerClass =
        isMoving && !isInit // маркер из инита всегда рисуем стоячим
          ? // Math.random() < 0.5 ?
          FIRE_MARKER_CONTAINER
          : BASIC_MARKER_CONTAINER;

      const acronym = getAcronymFromName(name);

      const htmlMarker = new mapgl.HtmlMarker(map, {
        coordinates: [lon, lat],
        interactive: DEBUG,
        html: getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth)
      });
      htmlMarker.id = id;

      if (markerClass === FIRE_MARKER_CONTAINER) {
        htmlMarker.setAnchor([58, 43]);
      } else {
        htmlMarker.setAnchor([18, 18]);
      }

      return htmlMarker;
    }

    function getBackgroundImageForAva(avaUrl) {
      return avaUrl !== null ? "background-image: url(" + avaUrl + ");" : null;
    }

    function getAcronymFromName(name) {
      return name
        .split(/\s/)
        .reduce((response, word) => (response += word.slice(0, 1)), "");
    }

    function getRotateHtmlText(azimuth) {
      return azimuth !== null ? azimuth + "deg" : "0deg";
    }

    function getInvertRotateHtmlText(azimuth) {
      return azimuth !== null ? azimuth * -1 + "deg" : "0deg";
    }

    function getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth) {
      var html = "";

      const backgroundImage = getBackgroundImageForAva(avaUrl);

      if (backgroundImage !== null) {
        acronym = "";
      }

      const rotateText = getRotateHtmlText(azimuth);
      const invertRotateText = getInvertRotateHtmlText(azimuth);

      const textClass = acronym != "" ? "ava-only-text" : "";

      if (markerClass === FIRE_MARKER_CONTAINER) {
        html = `
      <div id="marker-${id}" class="${FIRE_MARKER_CONTAINER}" style="transform: rotate(${rotateText});">
        <dotlottie-player src="https://rezonx3m.github.io/friends/static/fire.json" background="transparent" speed="1" style="width: 84px; height: 84px;" loop autoplay>
        </dotlottie-player>
        <div class="fired-ava-container">
          <div id="ava-${id}" style="${backgroundImage}; transform: rotate(${invertRotateText});" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
      } else {
        html = `<div id="marker-${id}">
        <div class="ava-container">
          <div id="ava-${id}" style="${backgroundImage};" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
      }
      return html;
    }

    function addDebugMarker(lon, lat) {
      if (ENABLE_DEBUG_MARKERS) {
        const debugMarker = new mapgl.Marker(map, {
          coordinates: [lon, lat]
        });
        if (debugMarkers.length >= maxDebugMarkersLenght) {
          const first = debugMarkers.shift();
          first.destroy();
        }
        debugMarkers.push(debugMarker);
      }
    }

    function toRadians(degrees) {
      return (degrees * Math.PI) / 180;
    }

    // Converts from radians to degrees.
    function toDegrees(radians) {
      return (radians * 180) / Math.PI;
    }

    function bearing(startLat, startLon, destLat, destLon) {
      startLat = toRadians(startLat);
      startLon = toRadians(startLon);
      destLat = toRadians(destLat);
      destLon = toRadians(destLon);

      y = Math.sin(destLon - startLon) * Math.cos(destLat);
      x =
        Math.cos(startLat) * Math.sin(destLat) -
        Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLon - startLon);
      brng = Math.atan2(y, x);
      brng = toDegrees(brng);
      return ((brng + 360) % 360) - 90;
    }

    function moveMarker(id, marker, prevLon, prevLat, nextLon, nextLat, time) {
      const mapLon = marker.getCoordinates()[0];
      const mapLat = marker.getCoordinates()[1];

      // @todo рассчитать расстояние между текущим положением на карте и тем, что должно быть финальным в последней анимации, в новую анимацию добавить две точки, а общее время разбить на два этапа пропорционально расстаянию
      const track = [
        { coordinates: [mapLon, mapLat], t: 0 },
        // { coordinates: [prevLon, prevLat], t: 0.2 },
        { coordinates: [nextLon, nextLat], t: time }
      ];

      // делаем анимацию для значимых движений
      if (
        Math.abs(mapLon - nextLon) > 0.0001 ||
        Math.abs(mapLat - nextLat) > 0.0001
      ) {
        moveOn(track, marker, id);
      }
    }

    function rotateMarker(id, azimuth) {
      const fixedAzimuth = azimuth + globalMapRotation;
      const avaElement = document.getElementById(`ava-${id}`);
      const markerElement = document.getElementById(`marker-${id}`);
      const invertAzimut = fixedAzimuth * -1;
      if (markerElement !== null) {
        markerElement.style.transform = `rotate(${fixedAzimuth}deg)`;
      }
      if (avaElement !== null) {
        avaElement.style.transform = `rotate(${invertAzimut}deg)`;
      }
    }

    async function moveOn(track, marker, userId) {
      // current segment index
      let i = 0;

      // startup absolute time
      const start = performance.now();

      // segment points
      let curr = track[i],
        next = track[i + 1];

      // сохраняем рандомный номер созданной анимации, чтобы не играть те, что не актуальны
      const animationRandomNumber = Math.random();
      if (userId) {
        globalStates[userId]["animationRandomNumber"] = animationRandomNumber;
      }

      while (
        next &&
        (userId == null ||
          globalStates[userId]["animationRandomNumber"] == animationRandomNumber)
      ) {
        // time from start, ms
        const dt = (performance.now() - start) / 1000;

        // position in segment
        const ratio = (dt - curr.t) / (next.t - curr.t);

        // get current pos via lienar interpolation
        const pos = lerp(curr.coordinates, next.coordinates, ratio);
        marker.setCoordinates(pos);

        // wait next animation frame
        await new Promise((resolve) => requestAnimationFrame(resolve));

        // iterate segments if needed
        if (dt > next.t) {
          i += 1;
          curr = next;
          next = track[i + 1];
        }
      }
    }

    function lerp(x, y, ratio) {
      return [x[0] + (y[0] - x[0]) * ratio, x[1] + (y[1] - x[1]) * ratio];
    }

    function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
      const R = 6371; // Radius of the earth in km
      const dLat = toRadians(lat2 - lat1); // deg2rad below
      const dLon = toRadians(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRadians(lat1)) *
        Math.cos(toRadians(lat2)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const d = R * c; // Distance in km
      return d;
    }

    function calculateAnimationTime(lastLat, lastLon, lat, lon, speed) {
      const distInMeters =
        getDistanceFromLatLonInKm(lastLat, lastLon, lat, lon) * 1000;
      const time = distInMeters / speed;
      return time * 1.1; // костыль +10%
    }

    function reRotateMarkers() {
      for (const id in globalStates) {
        if (globalStates[id]["state"] == STATE_MOVING) {
          rotateMarker(id, globalStates[id]["azimuth"]);
        }
      }
    }

    // при окончании вращения карты сохраняем поправочный коэффициент
    // шлем вьюпорт
    map.on("rotation", () => {
      globalMapRotation = map.getRotation();
      reRotateMarkers();
    });

    map.on("moveend", () => {
      sendBounds(globalWS);
      clusteriseMarkers(true);
    });

    map.on("move", () => { });

    function sendBounds(ws) {
      if (ws && ws.readyState == 1) {
        const bounds = map.getBounds();

        const message = {
          type: "viewportChanged",
          payload: {
            zoom: Math.floor(map.getZoom()),
            viewport: {
              topLeft: {
                lon: bounds.southWest[0],
                lat: bounds.northEast[1]
              },
              bottomRight: {
                lon: bounds.northEast[0],
                lat: bounds.southWest[1]
              }
            }
          }
        };

        const jsonMessage = JSON.stringify(message);
        ws.send(jsonMessage);
        if (DEBUG) {
          console.log("send bounds", jsonMessage);
        }
      }
    }

    function processStickerToMe(payload) {
      const senderId = payload.senderId;
      const stickerId = payload.stickerRecord.sticker.stickerId;
      const stickersCount = payload.stickerRecord.sticker.count;
      const htmlMarker = spawnEmoji(senderId, stickerId, stickersCount);
      setTimeout(function () {
        htmlMarker.destroy();
      }, 1000); // change time if changed animation css time
    }

    function spawnEmoji(senderId, stickerId, stickersCount) {
      //  startCoordinates = globalStates
      //const senderLon = globalStates[senderId]["lon"];
      //const senderLat = globalStates[senderId]["lat"];
      const senderMarker = globalMarkers[senderId];
      const senderLon = senderMarker.getCoordinates()[0];
      const senderLat = senderMarker.getCoordinates()[1];

      const mapCenter = map.getCenter();

      if (!SUPPORTED_EMOJI.includes(stickerId)) {
        console.log("unsupported emoji", stickerId);
        return;
      }

      const markerClass = "emogi-" + stickerId;

      const htmlMarker = new mapgl.HtmlMarker(map, {
        coordinates: [senderLon, senderLat],
        interactive: DEBUG, // @todo false
        html: `<div class="emoji-marker ${markerClass}"></div>`
      });
      htmlMarker.setAnchor([10, 16]);
      return htmlMarker;
    }

    function processStickerFromTo(payload) {
      const senderId = payload.senderId;
      const receiverId = payload.receiverId;
      const stickerId = payload.stickerRecord.sticker.stickerId;
      const stickersCount = payload.stickerRecord.sticker.count;
      const htmlMarker = spawnEmoji(senderId, stickerId, stickersCount);
      const coordinates = htmlMarker.getCoordinates();
      const nextLon = globalStates[receiverId]["lon"];
      const nextLat = globalStates[receiverId]["lat"];

      moveMarker(
        null,
        htmlMarker,
        coordinates[0],
        coordinates[1],
        nextLon,
        nextLat,
        1
      );
      setTimeout(function () {
        htmlMarker.destroy();
      }, 1000); // change time if changed animation css time
    }

    function clusteriseMarkers(forceRedraw = false) {
      if (ENABLE_CLUSTERS) {
        // @todo удалять только те, что распались

        const bounds = map.getBounds();
        const minPixelIntersection = 14;

        const container = document.getElementById("container");
        const countWidthSquare = Math.floor(
          container.clientWidth / minPixelIntersection
        );
        const countHeigthSquare = Math.floor(
          container.clientHeight / minPixelIntersection
        );

        const lonStep =
          (bounds.northEast[0] - bounds.southWest[0]) / countWidthSquare;
        const latStep =
          (bounds.northEast[1] - bounds.southWest[1]) / countHeigthSquare;

        var markersForClusters = [];

        for (const id in globalMarkers) {
          if (globalStates[id]["state"] == STATE_STOPPED) {
            const markersCoordinates = globalMarkers[id].getCoordinates();
            if (
              bounds.northEast[0] > markersCoordinates[0] &&
              bounds.southWest[0] < markersCoordinates[0] &&
              bounds.northEast[1] > markersCoordinates[1] &&
              bounds.southWest[1] < markersCoordinates[1]
            ) {
              markersForClusters.push(globalMarkers[id]);
            }
          }
        }

        // тупо взял тут https://ru.stackoverflow.com/questions/524772/%D0%9A%D0%B0%D0%BA%D0%BE%D0%B9-%D1%81%D1%83%D1%89%D0%B5%D1%81%D1%82%D0%B2%D1%83%D0%B5%D1%82-%D0%B0%D0%BB%D0%B3%D0%BE%D1%80%D0%B8%D1%82%D0%BC-%D0%B4%D0%BB%D1%8F-%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D1%8F-%D1%82%D0%BE%D1%87%D0%B5%D0%BA-%D0%B2-%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8
        /* псевдокласс точки */

        function Point(x, y, id) {
          this._x = x;
          this._y = y;
          this._id = id;
        }

        Point.prototype.getX = function () {
          return this._x;
        };

        Point.prototype.getY = function () {
          return this._y;
        };

        Point.prototype.getId = function () {
          return this._id;
        };

        /* расчеты */
        var points = new Array(); // массив точек

        for (const i in markersForClusters) {
          const markerCoordinates = markersForClusters[i].getCoordinates();
          points.push(
            new Point(
              markerCoordinates[0],
              markerCoordinates[1],
              markersForClusters[i].id
            )
          );
        }

        const mX = lonStep; // максимальное растояние по X
        const mY = latStep; // максимальное растояние по Y

        /* растояние между двумя точками */
        function calcDistance(p1, p2) {
          return Math.sqrt(
            Math.pow(p1.getX() - p2.getX(), 2) + Math.pow(p1.getY() - p2.getY(), 2)
          );
        }

        /* условия объединения */
        function isNear(p1, p2, mX, mY) {
          return Math.abs(p1.getX() - p2.getX()) <= mX &&
            Math.abs(p1.getY() - p2.getY()) <= mY
            ? true
            : false;
        }

        /* расчет матрицы расстояний */
        function calcMasDistances(mas) {
          var l = mas.length;
          var r = [];
          for (var i1 = 0; i1 < l; i1++) {
            r[i1] = [];
            for (var i2 = 0; i2 < l; i2++) {
              if (i1 == i2) {
                r[i1][i2] = 0;
              } else if (i1 < i2) {
                r[i1][i2] = calcDistance(mas[i1], mas[i2]);
              } else {
                r[i1][i2] = r[i2][i1];
              }
            }
          }
          return r;
        }

        /* смена элементов массива местами */
        function swap(n1, n2, mas) {
          var x;
          x = mas[n1];
          mas[n1] = mas[n2];
          mas[n2] = x;
          return mas;
        }

        /* расчет матрицы индексов близости */
        function calcMasIndexes(mas) {
          var l = mas.length;
          var r = [];

          var n = [];
          for (var i = 0; i < l; i++) {
            n[i] = i;
          }

          for (var i = 0; i < l; i++) {
            var ns = n.slice();
            var ds = mas[i].slice();

            for (var i1 = 0; i1 < l - 1; i1++) {
              for (var i2 = i1 + 1; i2 < l; i2++) {
                if (ds[i1] > ds[i2]) {
                  ns = swap(i1, i2, ns);
                  ds = swap(i1, i2, ds);
                }
              }
            }
            r[i] = ns.slice();
          }
          return r;
        }

        /* существование элемента в массиве */
        function exist(n, mas) {
          for (var i = 0; i < mas.length; i++) {
            if (n == mas[i]) {
              return true;
            }
          }
          return false;
        }

        /* кластеризация */
        function clastering(points, indexes, used, pn, cl) {
          if (!used[pn]) {
            cl[cl.length] = pn;
            used[pn] = true;

            for (var i = 1; i < points.length; i++) {
              var pn2 = indexes[pn][i];

              if (exist(pn2, cl)) {
                continue;
              } // условие выхода из цикла

              if (isNear(points[pn], points[pn2], mX, mY)) {
                clastering(points, indexes, used, pn2, cl);
              } else {
                break;
              }
            }
          }
        }

        var distances = calcMasDistances(points); // матрица растояний
        var indexes = calcMasIndexes(distances); // матрица индексов

        var used = []; // массив задействованных элементов
        for (var i = 0; i < points.length; i++) {
          used[i] = false;
        }

        var clasters = []; // матрица кластеров

        /* кластеризация */
        for (var i = 0; i < points.length; i++) {
          var cl = [];
          clastering(points, indexes, used, i, cl);
          if (cl.length > 0) {
            clasters.push(cl.slice());
          }
        }

        // конец спизженной часьи

        var finalClasters = [];
        var finalClastersIds = [];
        for (var i = 0; i < clasters.length; i++) {
          if (clasters[i].length > 1) {
            var ids = [];
            for (var j = 0; j < clasters[i].length; j++) {
              ids.push(points[clasters[i][j]].getId());
            }
            finalClasters.push(ids);
            finalClastersIds = finalClastersIds.concat(ids);
          }
        }

        var currentclusterMarkers = {};
        for (const i in finalClasters) {
          const clusterId = finalClasters[i].join("-");

          // приходится перерисовывать маркера, так как анимация слайдера ломается
          // @todo, переписать слайдер, чтобы не зависил от позиции на экране
          if (forceRedraw && clusterMarkers.hasOwnProperty(clusterId)) {
            clusterMarkers[clusterId].destroy();
            delete clusterMarkers[clusterId];
          }

          if (!clusterMarkers.hasOwnProperty(clusterId)) {
            const marker = createClusterMarker(finalClasters[i]);
            clusterMarkers[clusterId] = marker;
          }

          currentclusterMarkers[clusterId] = finalClasters[i];
        }

        Object.entries(clusterMarkers).forEach((entry) => {
          const [key, value] = entry;

          if (!currentclusterMarkers.hasOwnProperty(key)) {
            value.destroy();
            delete clusterMarkers[key];
          }
        });

        for (const i in markersForClusters) {
          if (!finalClastersIds.includes(markersForClusters[i].id)) {
            showMarker(markersForClusters[i].id);
          }
        }
      }
    }

    function shuffle(array) {
      let currentIndex = array.length,
        randomIndex;

      // While there remain elements to shuffle.
      while (currentIndex > 0) {
        // Pick a remaining element.
        randomIndex = Math.floor(Math.random() * currentIndex);
        currentIndex--;

        // And swap it with the current element.
        [array[currentIndex], array[randomIndex]] = [
          array[randomIndex],
          array[currentIndex]
        ];
      }

      return array;
    }

    function createClusterMarker(ids) {
      const sliderId =
        "slider-" + ids.join("-") + "-" + Math.floor(Math.random() * 1000000000);
      // рандомим, чтобы при пересоздании кластера не повторять порядок
      ids = shuffle(ids);
      var sumLon = 0;
      var sumLat = 0;
      for (const id in ids) {
        const coordinates = globalMarkers[ids[id]].getCoordinates();
        sumLon += coordinates[0];
        sumLat += coordinates[1];
        hideMarker(ids[id]);
      }
      const medianLon = sumLon / ids.length;
      const medianLat = sumLat / ids.length;

      const html = getHtmlForClusterMarker(ids, sliderId);

      const htmlMarker = new mapgl.HtmlMarker(map, {
        coordinates: [medianLon, medianLat],
        interactive: DEBUG,
        html: html
      });

      htmlMarker.setAnchor([18, 18]);

      waitForElement("#" + sliderId, 3000)
        .then(function () {
          new ItcSimpleSlider("#" + sliderId, {
            loop: true,
            autoplay: true,
            swipe: false,
            interval: 2000
          });
        })
        .catch(() => {
          console.log("Not found cluster div element");
        });

      return htmlMarker;
    }

    function getHtmlForClusterMarker(ids, sliderId) {
      var html = "";
      var items = "";

      for (const i in ids) {
        var acronym = "";
        const avaUrl = globalProfiles[ids[i]].logo;
        const name = globalProfiles[ids[i]].name;
        const backgroundImage = getBackgroundImageForAva(avaUrl);

        if (backgroundImage === null) {
          acronym = getAcronymFromName(name);
        }

        const itemClass = acronym != "" ? "itcss_item_text" : "itcss_item_ava";
        items += `
      <div class="itcss__item">
        <div style="${backgroundImage}"  class="${itemClass}">${acronym}</div>
      </div>`;
      }

      html = `<div id="marker-${sliderId}" >
           <div class="cluster-ava-container">
            <div class="ava">
              <div class="itcss" id="${sliderId}" >
                <div class="itcss__wrapper" style="background-color: gray;">
                  <div class="itcss__items">
                    ${items}
                  </div>
                </div>
              </div>
             </div>
           </div>
         </div>`;

      return html;
    }

    function hideMarker(id) {
      if (globalMarkers.hasOwnProperty(id)) {
        const divMarker = document.getElementById("marker-" + id);
        if (divMarker !== null) {
          divMarker.style.display = "none";
          idsUsersInClusters[id] = true;
        }
      }
    }

    function showMarker(id) {
      if (globalMarkers.hasOwnProperty(id)) {
        const divMarker = document.getElementById("marker-" + id);
        if (divMarker !== null) {
          divMarker.style.display = "block";
          delete idsUsersInClusters[id];
        }
      }
    }

    function waitForElement(querySelector, timeout) {
      return new Promise((resolve, reject) => {
        var timer = false;
        if (document.querySelectorAll(querySelector).length) return resolve();
        const observer = new MutationObserver(() => {
          if (document.querySelectorAll(querySelector).length) {
            observer.disconnect();
            if (timer !== false) clearTimeout(timer);
            return resolve();
          }
        });
        observer.observe(document.body, {
          childList: true,
          subtree: true
        });
        if (timeout)
          timer = setTimeout(() => {
            observer.disconnect();
            reject();
          }, timeout);
      });
    }

    // ------------------------------------ prewarm ------------------------------- //

    function prewarm() {
      const controlsDiv = document.getElementById("controls");
      SUPPORTED_EMOJI.forEach((emogi) => {
        const elemDiv = document.createElement("div");
        elemDiv.style.cssText = "width:0px;height:0px;";
        elemDiv.classList.add("emogi-" + emogi);
        controlsDiv.appendChild(elemDiv);
      });

      const elemDiv = document.createElement("div");
      elemDiv.innerHTML = `<div>
        <dotlottie-player src="https://rezonx3m.github.io/friends/static/fire.json" background="transparent" speed="1" style="width: 0px; height: 0px;">
        </dotlottie-player></div>`;
      controlsDiv.appendChild(elemDiv);
    }

    prewarm();

    // ------------------------------------ scenes ------------------------------- //

    switch (getParamScene) {
      case "2fest": {
        startScene2fest();
        break;
      }

      case "port": {
        startScenePort();
        break;
      }
    }

    function startScene2fest() {
      currentScene = "2fest";
      map.setCenter([82.9145, 55.0295]);
      map.setZoom(17.5);
      map.setPitch(50);
      map.setRotation(-170.85);
      document.getElementById("input-id").value = 45755262;
      connectButtonClick();
      document.getElementById("input-id").style.display = "none";
      document.getElementById("connect-button").style.display = "none";
    }

    function startScenePort() {
      addEventListener("keypress", (event) => {
        element = document.getElementById("popup");
        element.style.display = "block";
        if (event.code == "Enter") {
          setTimeout(function () {
            element.style.display = "none";
          }, 10000);
        }
      });

      currentScene = "port";
      map.setCenter([30.2423, 59.9235]);
      map.setZoom(18.2);
      map.setPitch(28.59);
      map.setRotation(142.11);

      const snow = new mapglSnow.Snow(map);

      document.getElementById("input-id").value = 46914337;
      connectButtonClick();
      document.getElementById("input-id").style.display = "none";
      document.getElementById("connect-button").style.display = "none";
    }

    // ------------------------------------ tests ------------------------------- //

    function perfTest() {
      const maxI = 100;
      const floor = Math.floor(Math.sqrt(maxI));
      for (i = 1; i <= maxI; i++) {
        testProfile.id = "test-" + i;
        testMessage.payload.id = testProfile.id;

        addProfile(testProfile);

        testMessage.payload.location.lon += 0.01;

        processMessage(testMessage);
        if (i % floor == 0) {
          testMessage.payload.location.lat += 0.01;
          testMessage.payload.location.lon -= 0.01 * floor;
          processMessage(testMessage);
          testMessageStickerFromTo.senderId = "test-" + i;
          testMessageStickerFromTo.receiverId = "test-" + (i - 9);
          processStickerFromTo(testMessageStickerFromTo);
        }
      }
    }

    // 45755262
    const testId1 = "abc123";
    const testId2 = "xyz789";
    const testId3 = "zzz666";
    const testId4 = "999999";

    var testMessageStickerFromTo = {
      senderId: testId1,
      receiverId: testId2,
      stickerRecord: {
        sticker: {
          stickerId: "fire",
          count: 1
        }
      }
    };

    var testProfile = {
      id: testId1,
      name: "Poop Boop",
      logo: "https://rezonx3m.github.io/friends/static/poop.png"
    };

    var testProfile2 = {
      id: testId2,
      name: "Foo Bar",
      logo: null
    };

    var testProfile3 = {
      id: testId3,
      name: "Zoo zoo",
      logo: null
    };

    var testProfile4 = {
      id: testId4,
      name: "Yo Yo",
      logo: "https://rezonx3m.github.io/friends/static/fire.png"
    };

    var testMessage = {
      type: "friendState",
      payload: {
        id: testId1,
        lastSeen: 16987361519730,
        location: {
          lat: 55.015,
          lon: 82.965,
          azimuth: 206.91267,
          speed: 160,
          accuracy: 17.823999404907227
        },
        battery: {
          level: 0.81
        },
        movement: {
          status: "moving",
          stoppedAt: 1698728448409
        }
      }
    };

    var testMessage2 = {
      type: "friendState",
      payload: {
        id: testId2,
        lastSeen: 16987361519730,
        location: {
          lat: 55.03,
          lon: 82.99,
          azimuth: 206.91267,
          speed: 160,
          accuracy: 17.823999404907227
        },
        battery: {
          level: 0.81
        },
        movement: {
          status: "moving",
          stoppedAt: 1698728448409
        }
      }
    };

    var testMessage3 = {
      type: "friendState",
      payload: {
        id: testId3,
        lastSeen: 16987361519730,
        location: {
          lat: 55.02,
          lon: 82.97,
          azimuth: 206.91267,
          speed: 160,
          accuracy: 17.823999404907227
        },
        battery: {
          level: 0.81
        },
        movement: {
          status: "moving",
          stoppedAt: 1698728448409
        }
      }
    };

    var testMessage4 = {
      type: "friendState",
      payload: {
        id: testId4,
        lastSeen: 16987361519730,
        location: {
          lat: 55.035,
          lon: 82.999,
          azimuth: 206.91267,
          speed: 160,
          accuracy: 17.823999404907227
        },
        battery: {
          level: 0.81
        },
        movement: {
          status: "moving",
          stoppedAt: 1698728448409
        }
      }
    };

    function testMove() {
      const multiplier1 = Math.random() > 0.5 ? 1 : -1;
      const multiplier2 = Math.random() > 0.5 ? 1 : -1;
      testMessage.payload.location.lon += 0.01 * multiplier1;
      testMessage.payload.location.lat += 0.01 * multiplier2;
      processMessage(testMessage);
    }

    function testRotate() {
      rotateMarker(testId1, Math.random() * 360);
    }

    function testRandomSticker() {
      const stickerN = Math.floor(Math.random() * SUPPORTED_EMOJI.length);
      testMessageStickerFromTo.stickerRecord.sticker.stickerId =
        SUPPORTED_EMOJI[stickerN];
      processStickerFromTo(testMessageStickerFromTo);
    }

    if (DEBUG) {
      addProfile(testProfile);
      addProfile(testProfile2);
      addProfile(testProfile3);
      addProfile(testProfile4);
      processMessage(testMessage);
      processMessage(testMessage2);
      processMessage(testMessage3);
      processMessage(testMessage4);
    }

    //startScenePort();




  </script>
</body>

</html>