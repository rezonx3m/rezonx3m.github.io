<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />
  <title>Друзья на карте</title>
  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>

  <style>
html,
body,
#container {
  margin: 0;
  width: 100%;
  height: 100%;
  overflow: hidden;
}

#main {
  padding: 0px;
  height: 100%;
}

#div-id {
  position: absolute;
  top: 30px;
  left: 30px;
}

.ava {
  width: 100%;
  height: 100%;
  max-width: 100%;
  max-height: 100%;
  border-radius: 0px;
  background-size: cover;
  background-color: gray;
  color: white;
  font-weight: bold;
  text-align: center;
  transition-duration: 0.2s;
  transition-property: transform;
}

.ava-only-text {
  display: flex;
  align-items: center;
  justify-content: center;
}

.fired-ava-container {
  height: 31px;
  width: 31px;
  border-radius: 100px;
  color: #262626;
  background: #ffffff;
  box-shadow: 0px 0px 5px white;
  overflow: hidden;
  position: absolute;
  top: 24px;
  left: 42px;
  box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
  overflow: hidden;
  border: 3px solid white;
  animation: scale 2s ease-in-out infinite;
}

.ava-container {
  height: 31px;
  width: 31px;
  border-radius: 100px;
  color: #262626;
  background: #ffffff;
  box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
  overflow: hidden;
  border: 3px solid white;
  animation: scale 2s ease-in-out infinite;
}

.fire-marker-container {
  transform-origin: 70% 50%;
  transition-duration: 0.2s;
  transition-property: transform;
}

@keyframes scale {
  0% {
    transform: scale(1);
  }
  5% {
    transform: scale(1);
  }
  45% {
    transform: scale(1.05);
  }
  55% {
    transform: scale(1.05);
  }
  95% {
    transform: scale(1);
  }
  100% {
    transform: scale(1);
  }
}

.emoji-marker {
  background-size: cover;
  background-repeat: no-repeat;
  background-position: center center;
  width: 20px;
  height: 20px;
  min-width: 20px;
  min-height: 20px;
  animation: emoji-scale 1s ease-in-out;
  -webkit-animation: emoji-scale 1s ease-in-out;
}

@keyframes emoji-scale {
  0% {
    transform: scale(1);
    -webkit-transform: scale(1);
  }
  70% {
    transform: scale(5);
    -webkit-transform: scale(5);
  }
  100% {
    transform: scale(1);
    -webkit-transform: scale(1);
  }
}

.hidden-test-button {
  display: none;
}

.emogi-fire {
  background-image: url("https://rezonx3m.github.io/friends/static/fire.png");
}
.emogi-greenheart {
  background-image: url("https://rezonx3m.github.io/friends/static/greenheart.png");
}
.emogi-snowball {
  background-image: url("https://rezonx3m.github.io/friends/static/snowball.png");
}
.emogi-poop {
  background-image: url("https://rezonx3m.github.io/friends/static/poop.png");
}
.emogi-wavinghand {
  background-image: url("https://rezonx3m.github.io/friends/static/wavinghand.png");
}
.emogi-angry {
  background-image: url("https://rezonx3m.github.io/friends/static/angry.png");
}
.emogi-eyes {
  background-image: url("https://rezonx3m.github.io/friends/static/eyes.png");
}
.emogi-party {
  background-image: url("https://rezonx3m.github.io/friends/static/party.png");
}

.emogi-go {
  background-image: url("https://rezonx3m.github.io/friends/static/go!.png");
}


  </style>
</head>

<body>
  <div id="main">
    <div id="container"></div>
  </div>
  
  <div id="controls">
    <div id="div-id">
      <input id="input-id" size="10" placeholder="userid" />
      <button onClick="changeId();">connect</button>
  
      <button class="hidden-test-button" onClick="testMove();">random move</button>
      <button class="hidden-test-button" onClick="testRotate();">random rotate</button>
      <button class="hidden-test-button" onClick="processStickerFromTo(testMessageStickerFromTo);">send fire</button>
      <button class="hidden-test-button" onClick="perfTest();">perf tests</button>
    </div>
  </div>

  <script type="text/javascript">
 const DEBUG = false;

const SUPPORTED_EMOJI = [
  "fire",
  "greenheart",
  "snowball",
  "poop",
  "wavinghand",
  "angry",
  "eyes",
  "party",
  "go"
];

if (DEBUG) {
  const buttons = document.getElementsByClassName("hidden-test-button");
  for (let i = buttons.length - 1; i >= 0; i--) {
    buttons[i].classList.remove("hidden-test-button");
  }
}

const map = new mapgl.Map("container", {
  center: [82.963483, 55.039882],
  zoom: 12,
  key: "042b5b75-f847-4f2a-b695-b5f58adc9dfd"
});

// фиксим рамер карты при ресайзе
window.addEventListener("resize", () => map.invalidateSize());

// 45755262
const testId1 = "abc123";
const testId2 = "xyz789";

var testProfile = {
  id: testId1,
  name: "Poop Boop",
  logo: "https://rezonx3m.github.io/friends/static/poop.png"
};

var testProfile2 = {
  id: testId2,
  name: "Foo Bar",
  logo: null
};

var testMessage = {
  type: "friendState",
  payload: {
    id: testId1,
    lastSeen: 1698736151973,
    location: {
      lat: 55.01,
      lon: 82.95,
      azimuth: 206.91267,
      speed: 160,
      accuracy: 17.823999404907227
    },
    battery: {
      level: 0.81
    },
    movement: {
      status: "moving",
      stoppedAt: 1698728448409
    }
  }
};

var testMessage2 = {
  type: "friendState",
  payload: {
    id: testId2,
    lastSeen: 1698736151973,
    location: {
      lat: 54.995,
      lon: 82.99,
      azimuth: 206.91267,
      speed: 160,
      accuracy: 17.823999404907227
    },
    battery: {
      level: 0.81
    },
    movement: {
      status: "moving",
      stoppedAt: 1698728448409
    }
  }
};

function testMove() {
  const multiplier1 = Math.random() > 0.5 ? 1 : -1;
  const multiplier2 = Math.random() > 0.5 ? 1 : -1;
  testMessage.payload.location.lon += 0.01 * multiplier1;
  testMessage.payload.location.lat += 0.01 * multiplier2;
  processMessage(testMessage);
}

function testRotate() {
  rotateMarker(testId1, Math.random() * 360);
}

var globalProfiles = {};
var globalMarkers = {};
var globalStates = {};
var globalWS = null;
var globalMapRotation = 0;

const SOCKET_PATH = "wss://zond.api.2gis.ru/api/1.1/user/:id/ws";

const FIRE_MARKER_CONTAINER = "fire-marker-container";
const BASIC_MARKER_CONTAINER = "basic-marker-container";
const STATE_MOVING = "moving";
const STATE_STOPPED = "stopped";

const BASE_ANIMATION_TIME = 0.2;
const BASE_SPEED = 1;

if (DEBUG) {
  addProfile(testProfile);
  addProfile(testProfile2);
  processMessage(testMessage);
  processMessage(testMessage2);
}

function changeId() {
  clearAll();
  globalWS = initSocket(document.getElementById("input-id").value);
}

function clearAll() {
  globalProfiles = {};
  for (const id in globalMarkers) {
    removeMarker(id);
  }
  globalMarkers = {};
  globalStates = {};

  if (globalWS !== null) {
    globalWS.close();
  }
}

function setStateConnected() {}

function initSocket(id) {
  const wssUrlPattern = SOCKET_PATH;
  const wssUrl = wssUrlPattern.replace(":id", id);
  const ws = new WebSocket(wssUrl);

  ws.onopen = function () {
    sendBounds(ws);
  };

  ws.onerror = function (e) {
    console.log("ws error");
    console.log(e);
  };
  ws.onclose = function () {
    console.log("ws closed");
  };

  ws.onmessage = function (msgevent) {
    const msg = JSON.parse(msgevent.data);
    processMessage(msg);
  };

  return ws;
}

function processMessage(msg) {
  switch (msg.type) {
    case "initialState":
      processInitState(msg.payload);
      break;

    case "friendState":
      processState(msg.payload);
      break;

    case "friendRemoved":
      removeProfile(msg.payload);
      break;

    case "profile":
      addProfile(msg.payload);
      break;

    case "stickersInitialState":
      break;

    case "stickerReceived":
      processStickerToMe(msg.payload);
      break;

    default:
      console.log("unsupported type", msg.type, msg.payload);
      break;
  }
}

function processInitState(payload) {
  payload.profiles.forEach((profile) => {
    addProfile(profile);
  });
  payload.states.forEach((state) => {
    processState(state);
  });
}

function addProfile(profile) {
  const key = profile.id;
  globalProfiles[key] = profile;
}

function removeProfile(id) {
  delete globalProfiles[id];
  removeMarker(id);
  delete globalStates[id];
}

function removeMarker(id) {
  if (globalMarkers.hasOwnProperty(id)) {
    globalMarkers[id].destroy();
    delete globalMarkers[id];
  }
}

function processState(state) {
  const id = state.id;
  const lon = state.location.lon;
  const lat = state.location.lat;
  const isInit = !globalStates.hasOwnProperty(id);

  const marker = isInit ? null : globalMarkers[id];
  const lastLon = isInit ? null : globalStates[id]["lon"];
  const lastLat = isInit ? null : globalStates[id]["lat"];

  const locationSpeed = state.location.hasOwnProperty("speed")
    ? state.location.speed
    : BASE_SPEED;
  const animationTime = isInit
    ? BASE_ANIMATION_TIME
    : calculateAnimationTime(lastLat, lastLon, lat, lon, state.location.speed);
  const azimuth = isInit
    ? null
    : bearing(marker.getCoordinates()[1], marker.getCoordinates()[0], lat, lon);

  if (isInit) {
    globalStates[id] = {};
  }

  const isMoving = state.movement.status == STATE_MOVING ? true : false;
  const avaUrl = globalProfiles[id].logo;
  const name = globalProfiles[id].name;

  // для дебага, чтобы проверить соответствуют ли маркера реальным позициям
  if (DEBUG) {
    const debugMarker = new mapgl.Marker(map, {
      coordinates: [lon, lat]
    });
  }

  switch (true) {
    case !isInit && !isMoving: // кейсы, когда маркер останавливается
      if (globalStates[id]["state"] == STATE_STOPPED) {
        // маркер остался стоять, но теоретически могла прилететь новая позиция
        moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
      } else {
        // маркер был движущимся, а стал cтоящим, поэтому заменяем
        moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
        globalMarkers[id] = addOrReplaceMarker(
          id,
          lon,
          lat,
          isInit,
          isMoving,
          null,
          avaUrl,
          name
        );
        globalStates[id]["state"] = STATE_STOPPED;
      }
      break;
    case !isInit && isMoving: // кейсы, когда маркер движется
      if (globalStates[id]["state"] == STATE_STOPPED) {
        // раньше стоял, начал двигаться, меняем маркер и стейт
        // рисуем маркер сперва в предыдущей точке
        globalMarkers[id] = addOrReplaceMarker(
          id,
          lastLon,
          lastLat,
          isInit,
          isMoving,
          azimuth,
          avaUrl,
          name
        );

        moveMarker(
          id,
          globalMarkers[id],
          lastLon,
          lastLat,
          lon,
          lat,
          animationTime
        );
        globalStates[id]["state"] = STATE_MOVING;
      } else {
        rotateMarker(id, azimuth);
        moveMarker(id, marker, lastLon, lastLat, lon, lat, animationTime);
      }
      break;
    case isInit:
      globalMarkers[id] = addOrReplaceMarker(
        id,
        lon,
        lat,
        isInit,
        false,
        null,
        avaUrl,
        name
      );
      globalStates[id]["state"] = STATE_STOPPED;
      break;
    default:
      console("hbz case");
  }

  globalStates[id]["lon"] = lon;
  globalStates[id]["lat"] = lat;
  globalStates[id]["azimuth"] = azimuth;
}

function addOrReplaceMarker(
  id,
  lon,
  lat,
  isInit,
  isMoving,
  azimuth,
  avaUrl,
  name
) {
  removeMarker(id);

  const markerClass =
    isMoving && !isInit // маркер из инита всегда рисуем стоячим
      ? // Math.random() < 0.5 ?
        FIRE_MARKER_CONTAINER
      : BASIC_MARKER_CONTAINER;

  const acronym = name
    .split(/\s/)
    .reduce((response, word) => (response += word.slice(0, 1)), "");

  const htmlMarker = new mapgl.HtmlMarker(map, {
    coordinates: [lon, lat],
    interactive: false,
    html: getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth)
  });

  if (markerClass === FIRE_MARKER_CONTAINER) {
    htmlMarker.setAnchor([58, 50]);
  } else {
    htmlMarker.setAnchor([18, 25]);
  }

  return htmlMarker;
}

function getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth) {
  var html = "";

  const backgroundImage =
    avaUrl !== null ? "background-image: url(" + avaUrl + ");" : null;

  if (backgroundImage !== null) {
    acronym = "";
  }

  const rotateText = azimuth !== null ? azimuth + "deg" : "0deg";
  const invertRotateText = azimuth !== null ? azimuth * -1 + "deg" : "0deg";

  const textClass = acronym != "" ? "ava-only-text" : "";

  if (markerClass === FIRE_MARKER_CONTAINER) {
    html = `
      <div id="marker-${id}" class="${markerClass}" style="transform: rotate(${rotateText});">
        <dotlottie-player src="https://rezonx3m.github.io/friends/static/fire.json" background="transparent" speed="1" style="width: 84px; height: 84px;" loop autoplay>
        </dotlottie-player>
        <div class="fired-ava-container">
          <div id="ava-${id}" style="${backgroundImage}; transform: rotate(${invertRotateText});" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
  } else {
    html = `<div id="marker-${id}" class="${markerClass}">
        <div class="ava-container">
          <div id="ava-${id}" style="${backgroundImage};" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
  }
  return html;
}

function toRadians(degrees) {
  return (degrees * Math.PI) / 180;
}

// Converts from radians to degrees.
function toDegrees(radians) {
  return (radians * 180) / Math.PI;
}

function bearing(startLat, startLon, destLat, destLon) {
  startLat = toRadians(startLat);
  startLon = toRadians(startLon);
  destLat = toRadians(destLat);
  destLon = toRadians(destLon);

  y = Math.sin(destLon - startLon) * Math.cos(destLat);
  x =
    Math.cos(startLat) * Math.sin(destLat) -
    Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLon - startLon);
  brng = Math.atan2(y, x);
  brng = toDegrees(brng);
  return ((brng + 360) % 360) - 90;
}

function moveMarker(id, marker, prevLon, prevLat, nextLon, nextLat, time) {
  const mapLon = marker.getCoordinates()[0];
  const mapLat = marker.getCoordinates()[1];

  // @todo рассчитать расстояние между текущим положением на карте и тем, что должно быть финальным в последней анимации, в новую анимацию добавить две точки, а общее время разбить на два этапа пропорционально расстаянию
  const track = [
    { coordinates: [mapLon, mapLat], t: 0 },
    // { coordinates: [prevLon, prevLat], t: 0.2 },
    { coordinates: [nextLon, nextLat], t: time }
  ];

  // делаем анимацию для значимых движений
  if (
    Math.abs(mapLon - nextLon) > 0.0001 ||
    Math.abs(mapLat - nextLat) > 0.0001
  ) {
    moveOn(track, marker, id);
  }
}

function rotateMarker(id, azimuth) {
  const fixedAzimuth = azimuth + globalMapRotation;
  const avaElement = document.getElementById(`ava-${id}`);
  const markerElement = document.getElementById(`marker-${id}`);
  const invertAzimut = fixedAzimuth * -1;
  markerElement.style.transform = `rotate(${fixedAzimuth}deg)`;
  avaElement.style.transform = `rotate(${invertAzimut}deg)`;
}

async function moveOn(track, marker, userId) {
  // current segment index
  let i = 0;

  // startup absolute time
  const start = performance.now();

  // segment points
  let curr = track[i],
    next = track[i + 1];

  // сохраняем рандомный номер созданной анимации, чтобы не играть те, что не актуальны
  const animationRandomNumber = Math.random();
  if (userId) {
    globalStates[userId]["animationRandomNumber"] = animationRandomNumber;
  }

  while (
    next &&
    (userId == null ||
      globalStates[userId]["animationRandomNumber"] == animationRandomNumber)
  ) {
    // time from start, ms
    const dt = (performance.now() - start) / 1000;

    // position in segment
    const ratio = (dt - curr.t) / (next.t - curr.t);

    // get current pos via lienar interpolation
    const pos = lerp(curr.coordinates, next.coordinates, ratio);
    marker.setCoordinates(pos);

    // wait next animation frame
    await new Promise((resolve) => requestAnimationFrame(resolve));

    // iterate segments if needed
    if (dt > next.t) {
      i += 1;
      curr = next;
      next = track[i + 1];
    }
  }
}

function lerp(x, y, ratio) {
  return [x[0] + (y[0] - x[0]) * ratio, x[1] + (y[1] - x[1]) * ratio];
}

function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
  const R = 6371; // Radius of the earth in km
  const dLat = toRadians(lat2 - lat1); // deg2rad below
  const dLon = toRadians(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(toRadians(lat1)) *
      Math.cos(toRadians(lat2)) *
      Math.sin(dLon / 2) *
      Math.sin(dLon / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  const d = R * c; // Distance in km
  return d;
}

function calculateAnimationTime(lastLat, lastLon, lat, lon, speed) {
  const distInMeters =
    getDistanceFromLatLonInKm(lastLat, lastLon, lat, lon) * 1000;
  const time = distInMeters / speed;
  return time;
}

function reRotateMarkers() {
  for (const id in globalStates) {
    if (globalStates[id]["state"] == STATE_MOVING) {
      rotateMarker(id, globalStates[id]["azimuth"]);
    }
  }
}

// при окончании вращения карты сохраняем поправочный коэффициент
// шлем вьюпорт
map.on("rotationend", () => {
  globalMapRotation = map.getRotation();
  reRotateMarkers();
});

map.on("moveend", () => {
  sendBounds(globalWS);
});

function sendBounds(ws) {
  if (ws) {
    const bounds = map.getBounds();
    const message = {
      type: "viewportChanged",
      payload: {
        zoom: Math.floor(map.getZoom()),
        viewport: {
          topLeft: {
            lon: bounds.northEast[0],
            lat: bounds.northEast[1]
          },
          bottomRight: {
            lon: bounds.southWest[0],
            lat: bounds.southWest[1]
          }
        }
      }
    };

    const jsonMessage = JSON.stringify(message);
    ws.send(jsonMessage);
    if (DEBUG) {
      console.log(jsonMessage);
    }
  }
}

function processStickerToMe(payload) {
  const senderId = payload.senderId;
  const stickerId = payload.stickerRecord.sticker.stickerId;
  const stickersCount = payload.stickerRecord.sticker.count;
  const htmlMarker = spawnEmoji(senderId, stickerId, stickersCount);
  setTimeout(function () {
    htmlMarker.destroy();
  }, 1000); // change time if changed animation css time
}

function spawnEmoji(senderId, stickerId, stickersCount) {
  //  startCoordinates = globalStates
  //const senderLon = globalStates[senderId]["lon"];
  //const senderLat = globalStates[senderId]["lat"];
  const senderMarker = globalMarkers[senderId];
  const senderLon = senderMarker.getCoordinates()[0];
  const senderLat = senderMarker.getCoordinates()[1];

  const mapCenter = map.getCenter();

  if (!SUPPORTED_EMOJI.includes(stickerId)) {
    console.log("unsupported emoji", stickerId);
    return;
  }

  const markerClass = "emogi-" + stickerId;

  const htmlMarker = new mapgl.HtmlMarker(map, {
    coordinates: [senderLon, senderLat],
    interactive: true, // @todo false
    html: `<div class="emoji-marker ${markerClass}"></div>`
  });
  htmlMarker.setAnchor([10, 16]);
  return htmlMarker;
}

function processStickerFromTo(payload) {
  const senderId = payload.senderId;
  const receiverId = payload.receiverId;
  const stickerId = payload.stickerRecord.sticker.stickerId;
  const stickersCount = payload.stickerRecord.sticker.count;
  const htmlMarker = spawnEmoji(senderId, stickerId, stickersCount);
  const coordinates = htmlMarker.getCoordinates();
  const nextLon = globalStates[receiverId]["lon"];
  const nextLat = globalStates[receiverId]["lat"];

  moveMarker(
    null,
    htmlMarker,
    coordinates[0],
    coordinates[1],
    nextLon,
    nextLat,
    1
  );
  setTimeout(function () {
    htmlMarker.destroy();
  }, 1000); // change time if changed animation css time
}

var testMessageStickerFromTo = {
  senderId: testId1,
  receiverId: testId2,
  stickerRecord: {
    sticker: {
      stickerId: "fire",
      count: 1
    }
  }
};

function perfTest() {
  const maxI = 1000;
  const floor = Math.floor(Math.sqrt(maxI));
  for (i = 1; i <= maxI; i++) {
    testProfile.id = "test-" + i;
    testMessage.payload.id = testProfile.id;

    addProfile(testProfile);

    testMessage.payload.location.lon += 0.01;

    processMessage(testMessage);
    if (i % floor == 0) {
      testMessage.payload.location.lat += 0.01;
      testMessage.payload.location.lon -= 0.01 * floor;
      processMessage(testMessage);
      testMessageStickerFromTo.senderId = "test-" + i;
      testMessageStickerFromTo.receiverId = "test-" + (i - 9);
      processStickerFromTo(testMessageStickerFromTo);
    }
  }
}


  </script>
</body>

</html>