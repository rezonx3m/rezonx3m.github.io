<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />
  <title>Друзья на карте</title>
  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>

  <style>
    html,
    body,
    #container {
      margin: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
    }

    #main {
      padding: 0px;
      height: 100%;
    }

    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
    }

    #connect-button {
      width: 100px;
    }

    #connect-status {
      background-color: #ff8f8f;
      width: 100px;
    }

    #test-buttons {
      display: none;
    }

    .test-buttons-line {
      padding-top: 3px;
    }

    .ava {
      width: 100%;
      height: 100%;
      max-width: 100%;
      max-height: 100%;
      /* border-radius: 0px; */
      background-size: cover;
      background-color: gray;
      color: white;
      font-weight: bold;
      text-align: center;
      transition-duration: 0.2s;
      transition-property: transform;
    }

    .ava-only-text {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .fired-ava-container {
      height: 31px;
      width: 31px;
      border-radius: 100px;
      color: #262626;
      background: #ffffff;
      box-shadow: 0px 0px 5px white;
      overflow: hidden;
      position: absolute;
      top: 24px;
      left: 42px;
      box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
      overflow: hidden;
      border: 3px solid white;
      animation: scale 2s ease-in-out infinite;
    }

    .ava-container {
      height: 31px;
      width: 31px;
      border-radius: 100px;
      color: #262626;
      background: #ffffff;
      box-shadow: 0px 0px 3px rgba(38, 38, 38, 0.8);
      overflow: hidden;
      border: 3px solid white;
      animation: scale 2s ease-in-out infinite;
    }

    .fire-marker-container {
      transform-origin: 70% 50%;
      transition-duration: 0.2s;
      transition-property: transform;
    }

    @keyframes scale {
      0% {
        transform: scale(1);
      }

      5% {
        transform: scale(1);
      }

      45% {
        transform: scale(1.05);
      }

      55% {
        transform: scale(1.05);
      }

      95% {
        transform: scale(1);
      }

      100% {
        transform: scale(1);
      }
    }

    .emoji-marker {
      background-size: cover;
      background-repeat: no-repeat;
      background-position: center center;
      width: 20px;
      height: 20px;
      min-width: 20px;
      min-height: 20px;
      animation: emoji-scale 1s ease-in-out;
      -webkit-animation: emoji-scale 1s ease-in-out;
    }

    @keyframes emoji-scale {
      0% {
        transform: scale(1);
        -webkit-transform: scale(1);
      }

      70% {
        transform: scale(5);
        -webkit-transform: scale(5);
      }

      100% {
        transform: scale(1);
        -webkit-transform: scale(1);
      }
    }

    .hidden-test-button {
      display: none;
    }

    .emogi-fire {
      background-image: url("https://cachizer1.2gis.com/common/8f10cf05-f9fd-467b-888b-ea9c38d48171.png?w=200&h=200");
    }

    .emogi-greenheart {
      background-image: url("https://cachizer2.2gis.com/common/6085e54d-15f0-41c8-90c8-3257b2c1c03a.png?w=200&h=200");
    }

    .emogi-snowball {
      background-image: url("https://cachizer1.2gis.com/common/07336686-7ecd-4f3d-afa8-925de33b6c62.png?w=200&h=200");
    }

    .emogi-poop {
      background-image: url("https://cachizer2.2gis.com/common/ab98af20-0d27-4e4d-8555-82c0fa0fe8b8.png?w=200&h=200");
    }

    .emogi-wavinghand {
      background-image: url("https://cachizer1.2gis.com/common/f3b8ac5d-1f67-44ff-b8c3-f6aceec3beb9.png?w=200&h=200");
    }

    .emogi-angry {
      background-image: url("https://cachizer2.2gis.com/common/339d8ffa-735f-47c9-b557-5cf3a4f6abb1.png?w=200&h=200");
    }

    .emogi-eyes {
      background-image: url("https://cachizer1.2gis.com/common/905959df-f128-4691-8686-dd9b11b9ce63.png?w=200&h=200");
    }

    .emogi-party {
      background-image: url("https://cachizer3.2gis.com/common/7e392598-710c-4340-80cb-c0b3b47b6741.png?w=200&h=200");
    }

    .emogi-go {
      background-image: url("https://cachizer3.2gis.com/common/466a8841-50d8-4b92-bea7-c280a693a25c.png?w=200&h=200");
    }

    .emogi-nav {
      background-image: url("https://cachizer2.2gis.com/common/e213fd69-105d-441c-8fe9-426c42b39d7c.png?w=200&h=200");
    }

    /* fade in out */

    #popup {
      position: absolute;
      top: 0px;
      left: 0px;
      width: 100%;
      height: 100%;
      background-image: url("https://rezonx3m.github.io/friends/static/port-qr-code.png");
      background-repeat: no-repeat;
      background-position: center center;
      -webkit-animation: fadeinout 10s linear infinite;
      animation: fadeinout 10s linear infinite;
      opacity: 0;
      display: none;
    }

    @-webkit-keyframes fadeinout {
      10% {
        opacity: 1;
      }

      90% {
        opacity: 1;
      }
    }

    @keyframes fadeinout {
      10% {
        opacity: 1;
      }

      90% {
        opacity: 1;
      }
    }
  </style>
</head>

<body>
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />

  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>
  <meta name='viewport' content='width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no' />

  <script src="https://mapgl.2gis.com/api/js/v1"></script>
  <script src="https://unpkg.com/@dotlottie/player-component@latest/dist/dotlottie-player.mjs" type="module"></script>

  <div id="main">
    <div id="container"></div>
  </div>

  <div id="popup" class="elementToFadeInAndOut">
  </div>

  <div id="controls">
    <div id="div-id">
      <input id="input-id" size="10" placeholder="userid" />
      <button id="connect-button" onClick="connectButtonClick();">connect</button>
      <button disabled id="connect-status">disconnected</button>
    </div>
    <div id="test-buttons">
      <div class="test-buttons-line">
        <button onClick="testMove();">random move</button>
        <button onClick="testRotate();">random rotate</button>
        <button onClick="testRandomSticker();">send random sticker</button>
        <div class="test-buttons-line">
          <button onClick="perfTest();">perf tests</button>
        </div>
        <div class="test-buttons-line">
          <button onClick="startScene2fest();">2fest scene</button>
          <button onClick="startScenePort();">port</button>
        </div>
      </div>
    </div>
  </div>

  <script type="text/javascript">
    const urlParams = new URLSearchParams(window.location.search);
    const getParamDebugMarkers = urlParams.get("debug_markers");
    const getParamDebug = urlParams.get("debug");
    const getParamUserId = urlParams.get("user_id");
    const getParamScene = urlParams.get("scene");
    const DEBUG = window.location.host == "cdpn.io" || getParamDebug === "true";
    const ENABLE_DEBUG_MARKERS = false || getParamDebugMarkers === "true";
    const ENABLE_AUTO_RECONNECT = true;
    var currentScene = null;

    var reconnectTimerId = null;
    var connectTimerId = null;
    var needReconnect = false;
    var isConnected = false;

    var movingLivenessTimeout = 100000;
    var stoppedLivenessTimeout = 100000;
    var serverTimestampShift = 0;

    const SUPPORTED_EMOJI = [
      "fire",
      "greenheart",
      "snowball",
      "poop",
      "wavinghand",
      "angry",
      "eyes",
      "party",
      "go",
      "nav"
    ];

    const map = new mapgl.Map("container", {
      center: [82.963483, 55.039882],
      zoom: 12,
      key: "042b5b75-f847-4f2a-b695-b5f58adc9dfd",
      floorsEnabled: false,
      minZoom: 2,
      maxZoom: 20,
      minPitch: 0,
      maxPitch: 70,
      lowZoomMaxPitch: 45
    });

    // фиксим рамер карты при ресайзе
    window.addEventListener("resize", () => map.invalidateSize());

    var globalProfiles = {};
    var globalMarkers = {};
    var globalStates = {};
    var globalWS = null;
    var globalMapRotation = 0;
    var debugMarkers = [];
    const maxDebugMarkersLenght = 1000;

    const SOCKET_PATH = "wss://zond.api.2gis.ru/api/1.1/user/:id/ws";

    const FIRE_MARKER_CONTAINER = "fire-marker-container";
    const BASIC_MARKER_CONTAINER = "basic-marker-container";
    const STATE_MOVING = "moving";
    const STATE_STOPPED = "stopped";

    const BASE_ANIMATION_TIME = 0.2;
    const BASE_SPEED = 1;

    if (DEBUG) {
      hideVisibilityTestButtons(false);
    }

    if (getParamUserId !== null) {
      document.getElementById("input-id").value = getParamUserId;
      connectButtonClick();
    }

    // скрытие кнопок дле тестов
    function hideVisibilityTestButtons(hide) {
      const button = document.getElementById("test-buttons");
      if (hide) {
        button.style.display = "none";
      } else {
        button.style.display = "block";
      }
    }

    // управления контролами и статусом коннекта
    function setConnectionState(state) {
      const button = document.getElementById("connect-button");
      const status = document.getElementById("connect-status");
      const input = document.getElementById("input-id");
      status.innerText = state;
      switch (state) {
        case "connected":
          status.style.backgroundColor = "#9cf19c";
          input.disabled = true;
          button.innerText = "disconnect";
          isConnected = true;
          break;
        case "reconnecting":
          status.style.backgroundColor = "#fc8016";
          break;
        case "connecting":
          status.style.backgroundColor = "#839bff";
          break;
        case "disconnected":
          status.style.backgroundColor = "#ff8f8f";
          button.innerText = "connect";
          input.disabled = false;
          isConnected = false;
          break;
      }
    }

    // нажатие в кнопку коннекта
    function connectButtonClick() {
      const userId = document.getElementById("input-id").value;
      if (userId.length > 0) {
        if (!isConnected) {
          hideVisibilityTestButtons(true);
          setConnectionState("connecting");
          globalWS = initSocket(document.getElementById("input-id").value);
        } else {
          if (globalWS) {
            needReconnect = false;
            globalWS.close();
          }
          setConnectionState("disconnected");
        }
      }
    }

    // уничтожение всех данных
    function clearAll() {
      globalProfiles = {};
      for (const id in globalMarkers) {
        removeMarker(id);
      }

      for (const id in globalMarkers) {
        removeMarker(id);
      }

      debugMarkers.forEach((element) => element.destroy());

      globalMarkers = {};
      globalStates = {};
    }

    // инициализация соккета
    function initSocket(id) {
      const wssUrlPattern = SOCKET_PATH;
      const wssUrl = wssUrlPattern.replace(":id", id);
      const ws = new WebSocket(wssUrl);

      clearInterval(reconnectTimerId);

      ws.onopen = function () {
        // чистимся от греха подальше, так как в коннекте прилетит инит
        clearAll();
        // отправка баундов, чтобы слежение было во вьюпорте
        sendBounds(ws);
        // при открытие соккета сообщаем, что его нужно реконнектить
        needReconnect = true;
        // циклически отправляем пинг, чтобы брайзер понял, что коннект сдох на случай проблем
        connectTimerId = setInterval(() => {
          ws.send('{"type":"ping-from-web-ui","payload":{}}');
        }, 1000);
        setConnectionState("connected");
      };

      ws.onclose = function () {
        console.log("ws closed");
        // стираем старый интервал
        clearInterval(connectTimerId);
        // шедулим новый интервал для реконнекта
        reconnectTimerId = setInterval(() => {
          if (needReconnect && ENABLE_AUTO_RECONNECT) {
            setConnectionState("reconnecting");
            globalWS = initSocket(id);
          }
        }, 5000);
      };

      ws.onerror = function (e) {
        console.log("ws error");
        console.log(e);
        ws.close();
      };

      ws.onmessage = function (msgevent) {
        const msg = JSON.parse(msgevent.data);
        processMessage(msg);
      };

      return ws;
    }

    // обработка входящих
    function processMessage(msg) {
      switch (msg.type) {
        case "initialState":
          processInitState(msg.payload);
          break;

        case "friendState":
          processState(msg.payload);
          break;

        case "friendRemoved":
          removeProfile(msg.payload);
          break;

        case "profile":
          addProfile(msg.payload);
          break;

        case "stickersInitialState":
          break;

        case "stickerReceived":
          processStickerToMe(msg.payload);
          break;

        default:
          console.log("unsupported type", msg.type, msg.payload);
          break;
      }
    }

    function processInitState(payload) {
      movingLivenessTimeout = payload.markerSettings.movingLivenessTimeout;
      stoppedLivenessTimeout = payload.markerSettings.stoppedLivenessTimeout;
      // поправка на серверное время
      serverTimestampShift = Date.now() - payload.serverTime;

      payload.profiles.forEach((profile) => {
        addProfile(profile);
      });
      payload.states.forEach((state) => {
        processState(state);
      });
    }

    function addProfile(profile) {
      const key = profile.id;
      globalProfiles[key] = profile;
      // @todo менять маркер, если поменялась аватарка
    }

    function removeProfile(id) {
      delete globalProfiles[id];
      removeMarker(id);
      delete globalStates[id];
    }

    function removeMarker(id) {
      if (globalMarkers.hasOwnProperty(id)) {
        globalMarkers[id].destroy();
        delete globalMarkers[id];
      }
    }

    function processState(state) {
      const id = state.id;
      const lastSeen = state.lastSeen;
      const lon = state.location.lon;
      const lat = state.location.lat;
      // первое вхождение на карту
      const isInit = !globalStates.hasOwnProperty(id);

      // дропаем "серые" (давно стоящие) маркера
      if (Date.now() + serverTimestampShift - lastSeen > stoppedLivenessTimeout) {
        removeMarker(id);
        return;
      }

      const marker = isInit ? null : globalMarkers[id];
      const lastLon = isInit ? null : globalStates[id]["lon"];
      const lastLat = isInit ? null : globalStates[id]["lat"];

      const locationSpeed = state.location.hasOwnProperty("speed")
        ? state.location.speed
        : BASE_SPEED;
      const animationTime = isInit
        ? BASE_ANIMATION_TIME
        : calculateAnimationTime(lastLat, lastLon, lat, lon, state.location.speed);
      const azimuth = isInit
        ? null
        : bearing(marker.getCoordinates()[1], marker.getCoordinates()[0], lat, lon);

      if (isInit) {
        globalStates[id] = {};
      }

      const isOldMovingData =
        Date.now() + serverTimestampShift - lastSeen > movingLivenessTimeout
          ? true
          : false;
      const isMoving =
        state.movement.status == STATE_MOVING && !isOldMovingData ? true : false;

      const avaUrl = globalProfiles[id].logo;
      const name = globalProfiles[id].name;

      // для дебага, чтобы проверить соответствуют ли маркера реальным позициям
      if (ENABLE_DEBUG_MARKERS) {
        const debugMarker = new mapgl.Marker(map, {
          coordinates: [lon, lat]
        });

        if (debugMarkers.length >= maxDebugMarkersLenght) {
          const first = debugMarkers.shift();
          first.destroy();
        }
        debugMarkers.push(debugMarker);
      }

      switch (true) {
        case !isInit && !isMoving: // кейсы, когда маркер останавливается
          if (globalStates[id]["state"] == STATE_STOPPED) {
            // маркер остался стоять, но теоретически могла прилететь новая позиция
            moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
          } else {
            // маркер был движущимся, а стал cтоящим, поэтому заменяем
            moveMarker(id, marker, lastLon, lastLat, lon, lat, BASE_ANIMATION_TIME);
            globalMarkers[id] = addOrReplaceMarker(
              id,
              lon,
              lat,
              isInit,
              isMoving,
              null,
              avaUrl,
              name
            );
            globalStates[id]["state"] = STATE_STOPPED;
          }
          break;
        case !isInit && isMoving: // кейсы, когда маркер движется
          if (globalStates[id]["state"] == STATE_STOPPED) {
            // раньше стоял, начал двигаться, меняем маркер и стейт
            // рисуем маркер сперва в предыдущей точке
            globalMarkers[id] = addOrReplaceMarker(
              id,
              lastLon,
              lastLat,
              isInit,
              isMoving,
              azimuth,
              avaUrl,
              name
            );

            moveMarker(
              id,
              globalMarkers[id],
              lastLon,
              lastLat,
              lon,
              lat,
              animationTime
            );
            globalStates[id]["state"] = STATE_MOVING;
          } else {
            rotateMarker(id, azimuth);
            moveMarker(id, marker, lastLon, lastLat, lon, lat, animationTime);
          }
          break;
        case isInit:
          globalMarkers[id] = addOrReplaceMarker(
            id,
            lon,
            lat,
            isInit,
            false,
            null,
            avaUrl,
            name
          );
          globalStates[id]["state"] = STATE_STOPPED;
          break;
        default:
          console("hbz case");
      }

      globalStates[id]["lon"] = lon;
      globalStates[id]["lat"] = lat;
      globalStates[id]["azimuth"] = azimuth;
    }

    function addOrReplaceMarker(
      id,
      lon,
      lat,
      isInit,
      isMoving,
      azimuth,
      avaUrl,
      name
    ) {
      removeMarker(id);

      const markerClass =
        isMoving && !isInit // маркер из инита всегда рисуем стоячим
          ? // Math.random() < 0.5 ?
          FIRE_MARKER_CONTAINER
          : BASIC_MARKER_CONTAINER;

      const acronym = name
        .split(/\s/)
        .reduce((response, word) => (response += word.slice(0, 1)), "");

      const htmlMarker = new mapgl.HtmlMarker(map, {
        coordinates: [lon, lat],
        interactive: DEBUG,
        html: getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth)
      });

      if (markerClass === FIRE_MARKER_CONTAINER) {
        htmlMarker.setAnchor([58, 50]);
      } else {
        htmlMarker.setAnchor([18, 25]);
      }

      return htmlMarker;
    }

    function getHtmlForMarker(id, markerClass, avaUrl, acronym, azimuth) {
      var html = "";

      const backgroundImage =
        avaUrl !== null ? "background-image: url(" + avaUrl + ");" : null;

      if (backgroundImage !== null) {
        acronym = "";
      }

      const rotateText = azimuth !== null ? azimuth + "deg" : "0deg";
      const invertRotateText = azimuth !== null ? azimuth * -1 + "deg" : "0deg";

      const textClass = acronym != "" ? "ava-only-text" : "";

      if (markerClass === FIRE_MARKER_CONTAINER) {
        html = `
      <div id="marker-${id}" class="${markerClass}" style="transform: rotate(${rotateText});">
        <dotlottie-player src="https://rezonx3m.github.io/friends/static/fire.json" background="transparent" speed="1" style="width: 84px; height: 84px;" loop autoplay>
        </dotlottie-player>
        <div class="fired-ava-container">
          <div id="ava-${id}" style="${backgroundImage}; transform: rotate(${invertRotateText});" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
      } else {
        html = `<div id="marker-${id}" class="${markerClass}">
        <div class="ava-container">
          <div id="ava-${id}" style="${backgroundImage};" class="ava ${textClass}">
            ${acronym}
          </div>
        </div>
      </div>`;
      }
      return html;
    }

    function toRadians(degrees) {
      return (degrees * Math.PI) / 180;
    }

    // Converts from radians to degrees.
    function toDegrees(radians) {
      return (radians * 180) / Math.PI;
    }

    function bearing(startLat, startLon, destLat, destLon) {
      startLat = toRadians(startLat);
      startLon = toRadians(startLon);
      destLat = toRadians(destLat);
      destLon = toRadians(destLon);

      y = Math.sin(destLon - startLon) * Math.cos(destLat);
      x =
        Math.cos(startLat) * Math.sin(destLat) -
        Math.sin(startLat) * Math.cos(destLat) * Math.cos(destLon - startLon);
      brng = Math.atan2(y, x);
      brng = toDegrees(brng);
      return ((brng + 360) % 360) - 90;
    }

    function moveMarker(id, marker, prevLon, prevLat, nextLon, nextLat, time) {
      const mapLon = marker.getCoordinates()[0];
      const mapLat = marker.getCoordinates()[1];

      // @todo рассчитать расстояние между текущим положением на карте и тем, что должно быть финальным в последней анимации, в новую анимацию добавить две точки, а общее время разбить на два этапа пропорционально расстаянию
      const track = [
        { coordinates: [mapLon, mapLat], t: 0 },
        // { coordinates: [prevLon, prevLat], t: 0.2 },
        { coordinates: [nextLon, nextLat], t: time }
      ];

      // делаем анимацию для значимых движений
      if (
        Math.abs(mapLon - nextLon) > 0.0001 ||
        Math.abs(mapLat - nextLat) > 0.0001
      ) {
        moveOn(track, marker, id);
      }
    }

    function rotateMarker(id, azimuth) {
      const fixedAzimuth = azimuth + globalMapRotation;
      const avaElement = document.getElementById(`ava-${id}`);
      const markerElement = document.getElementById(`marker-${id}`);
      const invertAzimut = fixedAzimuth * -1;
      markerElement.style.transform = `rotate(${fixedAzimuth}deg)`;
      avaElement.style.transform = `rotate(${invertAzimut}deg)`;
    }

    async function moveOn(track, marker, userId) {
      // current segment index
      let i = 0;

      // startup absolute time
      const start = performance.now();

      // segment points
      let curr = track[i],
        next = track[i + 1];

      // сохраняем рандомный номер созданной анимации, чтобы не играть те, что не актуальны
      const animationRandomNumber = Math.random();
      if (userId) {
        globalStates[userId]["animationRandomNumber"] = animationRandomNumber;
      }

      while (
        next &&
        (userId == null ||
          globalStates[userId]["animationRandomNumber"] == animationRandomNumber)
      ) {
        // time from start, ms
        const dt = (performance.now() - start) / 1000;

        // position in segment
        const ratio = (dt - curr.t) / (next.t - curr.t);

        // get current pos via lienar interpolation
        const pos = lerp(curr.coordinates, next.coordinates, ratio);
        marker.setCoordinates(pos);

        // wait next animation frame
        await new Promise((resolve) => requestAnimationFrame(resolve));

        // iterate segments if needed
        if (dt > next.t) {
          i += 1;
          curr = next;
          next = track[i + 1];
        }
      }
    }

    function lerp(x, y, ratio) {
      return [x[0] + (y[0] - x[0]) * ratio, x[1] + (y[1] - x[1]) * ratio];
    }

    function getDistanceFromLatLonInKm(lat1, lon1, lat2, lon2) {
      const R = 6371; // Radius of the earth in km
      const dLat = toRadians(lat2 - lat1); // deg2rad below
      const dLon = toRadians(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(toRadians(lat1)) *
        Math.cos(toRadians(lat2)) *
        Math.sin(dLon / 2) *
        Math.sin(dLon / 2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      const d = R * c; // Distance in km
      return d;
    }

    function calculateAnimationTime(lastLat, lastLon, lat, lon, speed) {
      const distInMeters =
        getDistanceFromLatLonInKm(lastLat, lastLon, lat, lon) * 1000;
      const time = distInMeters / speed;
      return time * 1.1; // костыль +10%
    }

    function reRotateMarkers() {
      for (const id in globalStates) {
        if (globalStates[id]["state"] == STATE_MOVING) {
          rotateMarker(id, globalStates[id]["azimuth"]);
        }
      }
    }

    // при окончании вращения карты сохраняем поправочный коэффициент
    // шлем вьюпорт
    map.on("rotationend", () => {
      globalMapRotation = map.getRotation();
      reRotateMarkers();
    });

    map.on("moveend", () => {
      sendBounds(globalWS);
    });

    function sendBounds(ws) {
      if (ws && ws.readyState == 1) {
        const bounds = map.getBounds();
        const message = {
          type: "viewportChanged",
          payload: {
            zoom: Math.floor(map.getZoom()),
            viewport: {
              topLeft: {
                lon: bounds.northEast[0],
                lat: bounds.northEast[1]
              },
              bottomRight: {
                lon: bounds.southWest[0],
                lat: bounds.southWest[1]
              }
            }
          }
        };

        const jsonMessage = JSON.stringify(message);
        ws.send(jsonMessage);
        if (DEBUG) {
          console.log(jsonMessage);
        }
      }
    }

    function processStickerToMe(payload) {
      const senderId = payload.senderId;
      const stickerId = payload.stickerRecord.sticker.stickerId;
      const stickersCount = payload.stickerRecord.sticker.count;
      const htmlMarker = spawnEmoji(senderId, stickerId, stickersCount);
      setTimeout(function () {
        htmlMarker.destroy();
      }, 1000); // change time if changed animation css time
    }

    function spawnEmoji(senderId, stickerId, stickersCount) {
      //  startCoordinates = globalStates
      //const senderLon = globalStates[senderId]["lon"];
      //const senderLat = globalStates[senderId]["lat"];
      const senderMarker = globalMarkers[senderId];
      const senderLon = senderMarker.getCoordinates()[0];
      const senderLat = senderMarker.getCoordinates()[1];

      const mapCenter = map.getCenter();

      if (!SUPPORTED_EMOJI.includes(stickerId)) {
        console.log("unsupported emoji", stickerId);
        return;
      }

      const markerClass = "emogi-" + stickerId;

      const htmlMarker = new mapgl.HtmlMarker(map, {
        coordinates: [senderLon, senderLat],
        interactive: DEBUG, // @todo false
        html: `<div class="emoji-marker ${markerClass}"></div>`
      });
      htmlMarker.setAnchor([10, 16]);
      return htmlMarker;
    }

    function processStickerFromTo(payload) {
      const senderId = payload.senderId;
      const receiverId = payload.receiverId;
      const stickerId = payload.stickerRecord.sticker.stickerId;
      const stickersCount = payload.stickerRecord.sticker.count;
      const htmlMarker = spawnEmoji(senderId, stickerId, stickersCount);
      const coordinates = htmlMarker.getCoordinates();
      const nextLon = globalStates[receiverId]["lon"];
      const nextLat = globalStates[receiverId]["lat"];

      moveMarker(
        null,
        htmlMarker,
        coordinates[0],
        coordinates[1],
        nextLon,
        nextLat,
        1
      );
      setTimeout(function () {
        htmlMarker.destroy();
      }, 1000); // change time if changed animation css time
    }

    // ------------------------------------ scenes ------------------------------- //

    switch (getParamScene) {
      case "2fest": {
        startScene2fest();
        break;
      }

      case "port": {
        startScenePort();
        break;
      }
    }

    function startScene2fest() {
      currentScene = "2fest";
      map.setCenter([82.9145, 55.0295]);
      map.setZoom(17.5);
      map.setPitch(50);
      map.setRotation(-170.85);
      document.getElementById("input-id").value = 45755262;
      connectButtonClick();
      document.getElementById("input-id").style.display = "none";
      document.getElementById("connect-button").style.display = "none";
    }

    function startScenePort() {
      addEventListener("keypress", (event) => {
        element = document.getElementById("popup");
        element.style.display = "block";
        if (event.code == "Enter") {
          setTimeout(function () {
            element.style.display = "none";
          }, 10000);
        }
      });

      currentScene = "port";
      map.setCenter([30.2423, 59.9235]);
      map.setZoom(18.2);
      map.setPitch(28.59);
      map.setRotation(142.11);
      document.getElementById("input-id").value = 46914337;
      connectButtonClick();
      document.getElementById("input-id").style.display = "none";
      document.getElementById("connect-button").style.display = "none";
    }
    // ------------------------------------ tests ------------------------------- //

    function prewarm() {
      const controlsDiv = document.getElementById("controls");
      SUPPORTED_EMOJI.forEach((emogi) => {
        const elemDiv = document.createElement("div");
        elemDiv.style.cssText = "width:0px;height:0px;";
        elemDiv.classList.add("emogi-" + emogi);
        controlsDiv.appendChild(elemDiv);
      });

      const elemDiv = document.createElement("div");
      elemDiv.innerHTML = `<div>
        <dotlottie-player src="https://rezonx3m.github.io/friends/static/fire.json" background="transparent" speed="1" style="width: 0px; height: 0px;">
        </dotlottie-player></div>`;
      controlsDiv.appendChild(elemDiv);
    }

    prewarm();

    // ------------------------------------ tests ------------------------------- //

    function perfTest() {
      const maxI = 100;
      const floor = Math.floor(Math.sqrt(maxI));
      for (i = 1; i <= maxI; i++) {
        testProfile.id = "test-" + i;
        testMessage.payload.id = testProfile.id;

        addProfile(testProfile);

        testMessage.payload.location.lon += 0.01;

        processMessage(testMessage);
        if (i % floor == 0) {
          testMessage.payload.location.lat += 0.01;
          testMessage.payload.location.lon -= 0.01 * floor;
          processMessage(testMessage);
          testMessageStickerFromTo.senderId = "test-" + i;
          testMessageStickerFromTo.receiverId = "test-" + (i - 9);
          processStickerFromTo(testMessageStickerFromTo);
        }
      }
    }

    // 45755262
    const testId1 = "abc123";
    const testId2 = "xyz789";

    var testMessageStickerFromTo = {
      senderId: testId1,
      receiverId: testId2,
      stickerRecord: {
        sticker: {
          stickerId: "fire",
          count: 1
        }
      }
    };

    var testProfile = {
      id: testId1,
      name: "Poop Boop",
      logo: "https://rezonx3m.github.io/friends/static/poop.png"
    };

    var testProfile2 = {
      id: testId2,
      name: "Foo Bar",
      logo: null
    };

    var testMessage = {
      type: "friendState",
      payload: {
        id: testId1,
        lastSeen: 16987361519730,
        location: {
          lat: 55.01,
          lon: 82.95,
          azimuth: 206.91267,
          speed: 160,
          accuracy: 17.823999404907227
        },
        battery: {
          level: 0.81
        },
        movement: {
          status: "moving",
          stoppedAt: 1698728448409
        }
      }
    };

    var testMessage2 = {
      type: "friendState",
      payload: {
        id: testId2,
        lastSeen: 16987361519730,
        location: {
          lat: 54.995,
          lon: 82.99,
          azimuth: 206.91267,
          speed: 160,
          accuracy: 17.823999404907227
        },
        battery: {
          level: 0.81
        },
        movement: {
          status: "moving",
          stoppedAt: 1698728448409
        }
      }
    };

    function testMove() {
      const multiplier1 = Math.random() > 0.5 ? 1 : -1;
      const multiplier2 = Math.random() > 0.5 ? 1 : -1;
      testMessage.payload.location.lon += 0.01 * multiplier1;
      testMessage.payload.location.lat += 0.01 * multiplier2;
      processMessage(testMessage);
    }

    function testRotate() {
      rotateMarker(testId1, Math.random() * 360);
    }

    if (DEBUG) {
      addProfile(testProfile);
      addProfile(testProfile2);
      processMessage(testMessage);
      processMessage(testMessage2);
    }

    function testRandomSticker() {
      const stickerN = Math.floor(Math.random() * SUPPORTED_EMOJI.length);
      testMessageStickerFromTo.stickerRecord.sticker.stickerId =
        SUPPORTED_EMOJI[stickerN];
      processStickerFromTo(testMessageStickerFromTo);
    }


  </script>
</body>

</html>